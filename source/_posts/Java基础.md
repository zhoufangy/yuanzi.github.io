title: Java基础
author: Yuanzi
date: 2020-02-20 17:50:52
tags:
---
#### String,StringBuilder,StringBuffer

| 区别          | 可变性 | 线程安全性 | 性能                        |
| ------------- | ------ | ---------- | --------------------------- |
| String        | X      | √          |                             |
| StringBuffer  | √      | √同步锁    |                             |
| StringBuilder | √      | X          | 比StringBuffer10%-15%的提升 |

总结：

```
1.操作少量的数据，使用String
2.单线程下操作大量数据，适用StringBuilder
3.多线程下操作大量数据，StringBuffer
```



#### equals和==区别

==对与基本类型来说是值比较，对与引用类型来说比较的是引用，而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把它变成了值比较，所以一般情况下equals比较的是值是否相等。        

#### 重写equals一定要重写hashcode方法吗？为什么？

重写equals一定要重写hashcode方法，否则程序无法正常运行，hashcode()方法必须遵从Object规范。相等的对象必须具有相等的hash code。

#### hashcode方法有什么作用?

hashcode的存在主要用于提高查找效率，先进行hashcode比较，如果不同，就没必要进行equals比较了，这样就大大较少了，equals比较的次数，当比较大量数据时效率就显著提高了。比如在集合中的使用。



### 一致性哈希 和哈希结果对10取模有什么区别吗
如果增加或删除机器时（N变化）代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模。然后进行大规模的数据迁移。为了解决这些问题引入一致性哈希，我们假设数据的id通过哈希函数转换成的哈希值范围是2^32，也就是0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上机器在环中的位置根据机器id（主机名或者主机IP，是主机唯一的就行）设计算出的哈希值对2^32取模对应到环上。那么一条数据如何确定归属哪台机器呢？我们可以在该数据对应环上的位置顺时针寻找离该位置最近的机器，将数据归属于该机器上…

### 实现这样一种高效插入、查找的有序集合，你会怎么做

我：我觉得对应一种数据结构吧，是什么来着……额……，就是一种数据结构，它的任意棵子树的头结点数值大于左子树的小于右子树的（没想起来是二叉搜索树，好笨），然后这样的话插入和查找的效率都是log(2,N)了

### 1.面向对象和面向过程

	面向过程性能更高，但是面向对象易维护、易复用、易扩展

### 2.java语言有哪些特点
	面向对象（封装，集成，多态）平台无关 可靠性 安全性 支持多线程

### 3.JVM、JDK、JRE
	JVM 虚拟机
	JDK java SDK
	JRE java 运行时环境
	.java文件 --jdk中javac编译-> .class文件（生成JVM可以理解的Java字节）--JVM-->机器可以执行的二进制机器码

### 4.OracleJDK 和OpenJDK对比
	OpenJDK是开源的参考模型，OracleJDK是它的一个实现，不是完全开源的
	OracleJDK比OpenJDK更稳定性能更好
	许可协议OracleJDK二进制代码获得许可OpenJDKGPL v2获得

### 5.Java和C++的区别

### 6.什么是Java程序的主类？应用程序和小程序的主类有和不同

### 7.Java应用程序与小程序之间差别

### 8.字符型常量和字符串常量的区别
    形式上：‘’ “”
    含义上：字符常量相当于一个整型值，字符串常量指地址值
    内存大小不同，字符常量占2个字节，字符串占若干个

### 9.构造器Constructor是否可以被Override？
    Constructor不可以被继承，所以不能被重写，但可以被overLoad。

### 10.重载和重写的区别
    重载
    Add(String a)
    Add(String a,int b)
    Add(int a, String b)
    
    重写
    父类Private方法不能被重写
    public String add（String a， String b）{}
    子类
    @Override (作用范围小于等于父类)
    public String add（String a， String b）{}

### 11.Java面向对象编程三大特性
    封装：对象属性私有化，开放部分属性供外界访问
    继承：继承父类
    多态：程序引用变量方法调用在编程时不确定，运行期间才确定
    实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）

### 12.String Stringbuffer Stringbuilder的区别？String为什么是不可变的？

    区别           可变性  线程安全性  性能 
    String           ×       √         
    StringBuffer     √       √同步锁    
    StringBuilder	√       ×          比StringBuffer10%-15%提升
    
    1.操作少量的数据，使用String
    2.单线程下操作大量数据，适用StringBuilder
    3.多线程下操作大量数据，StringBuffer

### 13.自动装箱与拆箱
    装箱：将基本类型用他们对应的引用类型包装起来
    拆箱：将包装类型转换为基本数据类型
### 14.在静态方法内调用一个非静态成员为什么是非法的
    静态方法里不能调用其他非静态变量，也不可以访问非静态变量成员。

### 15.在JAVA中定义一个不做事且没有参数的构造方法的作用。
    如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 　

### 16.import java和javax有什么区别？
    实际上java和javax没有区别。这都是一个名字。

### 17.接口和抽象类的区别是什么？
	1.接口默认方法是public。所有方法在接口中不能有实现，而抽象类可以有非抽象方法
	2.接口中除了static、final变量，不能有其他变量，而抽象类中不一定
	3.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口
	4.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写，所以不能使用private）
	5.从设计层面来讲，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。

### 18.成员变量与局部变量的区别？
	1.语法形式上，成员变量是属于类的，局部变量是在方法中定义的变量或是方法的参数。成员变量可以被public、private、static等修饰，而局部变量不能被访问控制修饰符以及static修饰，但是成员变量和局部变量都能被final修饰。
	2.存储方式上,成员变量使用static修饰，那么这个成员变量是属于类的，如果没有static修饰，则属于实例的，而对象存在于堆内存，局部变量存在于占内存。
	3.生存时间上，成员变量是对象的一部分，随对象的创建而存在，局部变量随方法的调用而自动消失
	4.成员变量如果没有赋初值，会自动以类型的默认值而赋值（final修饰的成员变量也必须显式赋值），局部变量不会自动赋值。

### 19。创建一个对象用什么运算符?对象实体与对象引用有何不同?
	new
	new创建对象实例，对象实例在堆内存，对象引用指向对象实例，对象引用在栈内存。

### 20. 什么是方法的返回值?返回值在类的方法里的作用是什么?
	返回值的作用:接收出结果，使得它可以用于其他的操作！

### 21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?
    主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

### 22. 构造方法有哪些特性？
	1.名字与类名相同。
	2.没有返回值，但不能用void声明构造函数。
	3.生成类的对象时自动执行，无需调用。

### 23. 静态方法和实例方法有何不同
    在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
    静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。


​    




Java

title: 集合
author: Yuanzi
tags: [Java]
categories:

  - 面试
date: 2020-02-20 00:07:00
---
### 集合

<https://juejin.im/post/5c788d986fb9a049f154e479>

#### HashMap原理

HashMap是java.util.Map 底下的一个实现类，基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。

#### HashMap在JDK1.7和1.8区别

1.8中使用红黑树优化了查询效率。

DK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。查询效率低下。1.8后引入了 红黑树（查找时间复杂度为 O(logn)）来优化

#### HashMap hash碰撞

当两个对象hashcode相同时会产生hash碰撞，HashMap将会抛出异常，或者不存储。但是两个对象就算hashcode相同，也可能不相等。

MD5解密就是利用的hash碰撞。

因为hashcode相同，所以bucket位置相同，碰撞会发生。因为HashMap使用链表存储对象，这个Map.Entry对象会存储在链表中。

hashcode()用于键调用等，equals()方法仅用于获取值对象。使用不可变的对象作为键，并且采用合适的equals()和hashcode()方法，将会减少碰撞的发生，提高效率。例如使用String、Interger。

#### 解决hash冲突的四种方法

1.开放地址法

2.再哈希法：产生冲突时，计算另一个哈希函数地址，直到冲突不再发生(构造不同的哈希函数)。

3.链地址法：将所有哈希地址相同的记录都链接在同一个链表中。(HashMap采用这种)

4.建立一个公共溢出区，把冲突的记录都放在另一个存储空间，不放在表里面。

#### 如果两个键hashcode相同，如何获取值对象？

调用get()方法找到bucket位置，再调用keys.equals()方法去找到链表中的正确节点，最终找到值对象。

#### HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？

默认负载因子大小为0.75，也就是说当一个map填满75%bucket的时候回创建原来两倍大小的bucket数组，来重新调整map大小，并将原来的对象放入新的bucket数组中，做rehashing。

#### 重新调整HashMap大小存在什么问题？

当多线程情况下，可能会产生条件竞争(race condition)。

如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tailtraversing)。如果条件竞争发生了，那么就死循环了。

所以多线程情况下，建议用ConcurrentHashMap。

#### ConcurrentHashmap原理

ConcurrentHashMap 是由一个Segment数组和多个HashEntry组成，采用的是分段锁技术，当进行put操作时，会进行第一次key的hash来定位Segment位置，如果该Segment没有初始化，就会通过CAS操作进行赋值。其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。

1.8中使用的是Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，比较趋近于优化过且线程安全的HashMap。

JDK1.8中的ConcurrentHashMap不再使用Segment分段锁，而是以table数组的头结点作为synchronized的锁。和JDK1.8中的HashMap类似，对于hashCode相同的时候，在Node节点的数量少于8个时，这时的Node存储结构是链表形式，时间复杂度为O(N)，当Node节点的个数超过8个时，则会转换为红黑树，此时访问的时间复杂度为O(long(N))。

#### ConcurrentHashmap是如何实现线程安全的？

- 使用volatile保证当Node中的值变化时对于其他线程是可见的

- 使用table数组的头结点作为synchronized的锁来保证写操作的安全

- 当头结点为null时，使用CAS操作来保证数据能正确的写入。

  <https://juejin.im/post/5d8979e0e51d4561e623723d>

#### hashTable hashMap ConcurrentHashMap 的区别

|                   | 数据结构                                     | 线程安全                                              | 线程安全 | 扩容                                                |
| ----------------- | -------------------------------------------- | ----------------------------------------------------- | -------- | --------------------------------------------------- |
| hashTable         | able, count, threshold, loadFactor, modCount |                                                       | √        | 初始容量11，2倍-1扩容                               |
| hashMap           | 数组+链表                                    | 红黑树                                                | X        | 初始容量16，2倍扩容                                 |
| ConcurrentHashMap | Segment数组和多个HashEntry组成               | Node数组+链表+红黑树  并发控制使用Synchronized和CAS来 | √        | 扩容时针针对某一段时间扩容。不会打乱整个map重新排序 |

总结：Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。

<https://juejin.im/post/5add97a46fb9a07aa212f4c0

#### LinkedList、ArrayList和HashMap的区别

•LinkedList 底层是基于双向链表实现的，而 ArrayList 底层是基于动态数组实现的；•查询的时候 LinkedList 的效率要低于 ArrayList，因为 LinkedList 需要遍历链表，而 ArrayList 底层数组根据下标直接获取数据。•插入删除数据的时候，LinkedList 效率比ArrayList 效率高，因为 ArrayList 在数据多的情况下会进行数组扩容或移动数组。

ArrayList：数组集合。 查询、修改、新增（尾部新增）快，删除、新增（队列中间）慢，适用于查询、修改较多的场景。

 LinkedList：双向链表集合。查询、修改慢（需要遍历集合），新增，删除快（只需要修改前后节点的链接即可），适用于新增、删除较多的场景。

 HashMap：结合数组和链表的优势，期望做到增删改查都快速，时间复杂度接近于O(1)。当hash算法较好时，hash冲突较低。适用于增删改查所有场景。

<https://blog.csdn.net/a745233700/article/details/80803541?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>

#### String,StringBuilder,StringBuffer

| 区别          | 可变性 | 线程安全性 | 性能                        |
| ------------- | ------ | ---------- | --------------------------- |
| String        | X      | √          |                             |
| StringBuffer  | √      | √同步锁    |                             |
| StringBuilder | √      | X          | 比StringBuffer10%-15%的提升 |

总结：

```
1.操作少量的数据，使用String
2.单线程下操作大量数据，适用StringBuilder
3.多线程下操作大量数据，StringBuffer
```



#### equals和==区别

==对与基本类型来说是值比较，对与引用类型来说比较的是引用，而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把它变成了值比较，所以一般情况下equals比较的是值是否相等。        

#### 重写equals一定要重写hashcode方法吗？为什么？

重写equals一定要重写hashcode方法，否则程序无法正常运行，hashcode()方法必须遵从Object规范。相等的对象必须具有相等的hash code。

#### hashcode方法有什么作用?

hashcode的存在主要用于提高查找效率，先进行hashcode比较，如果不同，就没必要进行equals比较了，这样就大大较少了，equals比较的次数，当比较大量数据时效率就显著提高了。比如在集合中的使用。



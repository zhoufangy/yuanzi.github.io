<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuanzi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoufangy.github.io/"/>
  <updated>2020-03-25T18:42:39.311Z</updated>
  <id>http://zhoufangy.github.io/</id>
  
  <author>
    <name>Yuanzi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://zhoufangy.github.io/2020/03/26/java8/"/>
    <id>http://zhoufangy.github.io/2020/03/26/java8/</id>
    <published>2020-03-26T00:07:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>新特性简介：</p><p>Lambda表达式简化代码</p><p>Stream API 便于并行，速度更快</p><p>Optional最大化的减少了空指针异常，防止代码膨胀。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6qui5kglj30s41fe1kx.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新特性简介：&lt;/p&gt;
&lt;p&gt;Lambda表达式简化代码&lt;/p&gt;
&lt;p&gt;Stream API 便于并行，速度更快&lt;/p&gt;
&lt;p&gt;Optional最大化的减少了空指针异常，防止代码膨胀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/larg
      
    
    </summary>
    
      <category term="Java" scheme="http://zhoufangy.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://zhoufangy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://zhoufangy.github.io/2020/03/11/HashMap/"/>
    <id>http://zhoufangy.github.io/2020/03/11/HashMap/</id>
    <published>2020-03-11T14:55:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HashMap原理&quot;&gt;&lt;a href=&quot;#HashMap原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap原理&quot;&gt;&lt;/a&gt;HashMap原理&lt;/h3&gt;
      
    
    </summary>
    
      <category term="interview" scheme="http://zhoufangy.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>中台</title>
    <link href="http://zhoufangy.github.io/2020/03/04/%E4%B8%AD%E5%8F%B0/"/>
    <id>http://zhoufangy.github.io/2020/03/04/中台/</id>
    <published>2020-03-04T17:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install antd --save 下载全部包</span><br><span class="line">yarn add antd 锁版本</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install antd --save 下载全部包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="admin" scheme="http://zhoufangy.github.io/categories/admin/"/>
    
    
  </entry>
  
  <entry>
    <title>工具</title>
    <link href="http://zhoufangy.github.io/2020/03/04/tools/"/>
    <id>http://zhoufangy.github.io/2020/03/04/tools/</id>
    <published>2020-03-04T17:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>微软远程开发插件</p><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack</a></p><p>proxifier</p><p>网站</p><p><a href="https://www.journaldev.com/" target="_blank" rel="noopener">https://www.journaldev.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运维&quot;&gt;&lt;a href=&quot;#运维&quot; class=&quot;headerlink&quot; title=&quot;运维&quot;&gt;&lt;/a&gt;运维&lt;/h3&gt;&lt;p&gt;微软远程开发插件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?it
      
    
    </summary>
    
      <category term="tools" scheme="http://zhoufangy.github.io/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>命令</title>
    <link href="http://zhoufangy.github.io/2020/03/01/%E5%91%BD%E4%BB%A4/"/>
    <id>http://zhoufangy.github.io/2020/03/01/命令/</id>
    <published>2020-03-01T17:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>command+shift+t 打开上次网页</p><p>command+T 、D 新开tab</p><p>command+w 关闭tab</p><p>command+X 删除当前行</p><h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h1><p><strong>查询java端口号 </strong></p><p>Jdk自带的jps命令</p><p>$ jps</p><p>linux系统提供的ps命令</p><p>$ ps -ef | grep java</p><p><strong>查看jvm的GC情况</strong></p><p>jstat [Options] vmid [interval] [count]<br>参数说明：<br>Options，选项，我们一般使用 -gcutil 查看gc情况<br>vmid，VM的进程号，即当前运行的java进程号<br>interval，间隔时间，单位为秒或者毫秒<br>count，打印次数，如果缺省则打印无数次</p><p>结果说明<br>        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S0C：年轻代中第一个survivor（幸存区）的容量 (字节) </span><br><span class="line">S1C：年轻代中第二个survivor（幸存区）的容量 (字节) </span><br><span class="line">S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节) </span><br><span class="line">S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节) </span><br><span class="line">EC：年轻代中Eden（伊甸园）的容量 (字节) </span><br><span class="line">EU：年轻代中Eden（伊甸园）目前已使用空间 (字节) </span><br><span class="line">OC：Old代的容量 (字节) </span><br><span class="line">OU：Old代目前已使用空间 (字节) </span><br><span class="line">PC：Perm(持久代)的容量 (字节) </span><br><span class="line">PU：Perm(持久代)目前已使用空间 (字节) </span><br><span class="line">YGC：从应用程序启动到采样时年轻代中gc次数 </span><br><span class="line">YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) </span><br><span class="line">FGC：从应用程序启动到采样时old代(全gc)gc次数 </span><br><span class="line">FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) </span><br><span class="line">GCT：从应用程序启动到采样时gc用的总时间(s) </span><br><span class="line">NGCMN：年轻代(young)中初始化(最小)的大小 (字节) </span><br><span class="line">NGCMX：年轻代(young)的最大容量 (字节) </span><br><span class="line">NGC：年轻代(young)中当前的容量 (字节) </span><br><span class="line">OGCMN：old代中初始化(最小)的大小 (字节) </span><br><span class="line">OGCMX：old代的最大容量 (字节) </span><br><span class="line">OGC：old代当前新生成的容量 (字节) </span><br><span class="line">PGCMN：perm代中初始化(最小)的大小 (字节) </span><br><span class="line">PGCMX：perm代的最大容量 (字节)   </span><br><span class="line">PGC：perm代当前新生成的容量 (字节) </span><br><span class="line">S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 </span><br><span class="line">S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 </span><br><span class="line">E：年轻代中Eden（伊甸园）已使用的占当前容量百分比 </span><br><span class="line">O：old代已使用的占当前容量百分比 </span><br><span class="line">P：perm代已使用的占当前容量百分比 </span><br><span class="line">S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节) </span><br><span class="line">S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节) </span><br><span class="line">ECMX：年轻代中Eden（伊甸园）的最大容量 (字节) </span><br><span class="line">DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满） </span><br><span class="line">TT： 持有次数限制 </span><br><span class="line">MTT ： 最大持有次数限制</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h1&gt;&lt;p&gt;command+shift+t 打开上次网页&lt;/p&gt;
&lt;p&gt;command+T 、D 新开tab&lt;/p&gt;
&lt;p&gt;command+w 
      
    
    </summary>
    
      <category term="tools" scheme="http://zhoufangy.github.io/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>深入浅出React和Redux(实战)-程墨</title>
    <link href="http://zhoufangy.github.io/2020/03/01/React&amp;Redux/"/>
    <id>http://zhoufangy.github.io/2020/03/01/React&amp;Redux/</id>
    <published>2020-03-01T14:55:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-相关概念"><a href="#React-相关概念" class="headerlink" title="React 相关概念"></a>React 相关概念</h3><p>UI=render(state)</p><p>React理念：</p><p>1.响应式编程(Reactive Programming)</p><p>2.基于组件开发应用</p><p>Redux：</p><p>Component：React首要思想是通过组件(Component)来开发应用</p><p>JSX：JavaScript的语法扩展，在JavaScript中编写像Html一样的代码。</p><p>Webpack：进行模块打包</p><p>Babel：转译JavaScript代码</p><p>ES6语法糖，由Webpack和Babel转译成所有浏览器都支持的ES5语法</p><p>Virtual DOM ：每次渲染都只重新渲染最少的DOM元素，比对上次生成的Virtual DOM树，进行差异化修改。</p><p>​    Virtual DOM对DOM树的抽象，DOM树：对HTML的抽象。</p><h3 id="React工作方式的优点"><a href="#React工作方式的优点" class="headerlink" title="React工作方式的优点"></a>React工作方式的优点</h3><p>JQuery:直观易懂，但代码往往互相纠缠，难以维护，特别是项目逐渐变得庞大时。</p><p>React：利用函数式编程思维来解决用户界面渲染的问题，最大的优势是开发者的效率会大大提高，开发出来的代码可维护性和可阅读性也大大增强。</p><p>事件</p><p>事件    —&gt;    render —&gt;    Virtual DOM —&gt; DOM修改</p><p>事件</p><h3 id="设计高质量的React组件"><a href="#设计高质量的React组件" class="headerlink" title="设计高质量的React组件"></a>设计高质量的React组件</h3><p>合理的分而治之，尽量保持一个组件只做一件事。</p><p>划分组件边界的原则:高内聚(High Cohesion)，低耦合(Low Couping)</p><h4 id="React组件的数据种类"><a href="#React组件的数据种类" class="headerlink" title="React组件的数据种类"></a>React组件的数据种类</h4><p>​    prop：组件的对外接口</p><p>​        propTypes：参数检查，开发时辅助检查，发布时可以使用 babel-react-optimize自动去除。</p><p>​        需要引入prop-type插件</p><p>​    state：组件的内部状态，赋值需要使用this.setState</p><p>​    prop和state的区别</p><p>​        prop用于定义外部接口，state用于记录内部状态。</p><p>​        prop的赋值在外部世界使用组件时，state的赋值在组件内部。</p><p>​        组件不应该改变prop的值，而state存在的目的就是让组件来改变的。</p><h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><h5 id="装载过程-Mount-，组件第一次在DOM树中渲染的过程。"><a href="#装载过程-Mount-，组件第一次在DOM树中渲染的过程。" class="headerlink" title="装载过程(Mount)，组件第一次在DOM树中渲染的过程。"></a>装载过程(Mount)，组件第一次在DOM树中渲染的过程。</h5><p>​    Constructor</p><p>​        初始化state</p><p>​        绑定成员函数的this环境</p><p>​    getInitialState：返回值用来初始化组件的this.state,但是只有用React.createClass(废弃)方法创造的组件类才会生效。</p><p>​    getDefaultProps：返回值可以作为props的初始值，但是只有用React.createClass方法创造的组件类才会生效。</p><p>​    componentWillMount：在render之前调用，可以在服务端和浏览器端被调用</p><p>​    render：返回JSX描述的结构，最终由React来操作渲染过程。</p><p>​    componentDidMount：在render之后调用，只能在浏览器端被调用。可以执行其他UI库代码，比如JQuery</p><h5 id="更新过程-Update-，组件被重新渲染的过程。"><a href="#更新过程-Update-，组件被重新渲染的过程。" class="headerlink" title="更新过程(Update)，组件被重新渲染的过程。"></a>更新过程(Update)，组件被重新渲染的过程。</h5><p>​    componentWillReceiveProps：只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发componentWillReceiveProps函数。</p><p>​    shouldComponentUpdate：决定了组件什么时候不需要渲染。返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续</p><p>​    componentWillUpdate</p><p>​    render</p><p>​    componentDidUpdate：无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。</p><h5 id="卸载过程-Unmount-，组件从DOM中删除的过程。"><a href="#卸载过程-Unmount-，组件从DOM中删除的过程。" class="headerlink" title="卸载过程(Unmount)，组件从DOM中删除的过程。"></a>卸载过程(Unmount)，组件从DOM中删除的过程。</h5><p>​    componentWillUnmount：处理清理工作，如在componentDidMount中用非React方法创造的DOM元素，需要在componentWillUnmount中清理掉，以避免可能造成的内存泄露。</p><p>问题</p><p>1.React的PropTypes的string类型没有定义</p><p>原因：React从V15.5版本就不支持PorpTypes属性了，改到了prop-types里了。</p><p>解决办法：</p><pre><code>1）下载prop-types包npm install --save-dev prop-types2）引入代码import PropTypes from &apos;prop-types&apos;;</code></pre><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux是Flux框架的巨大改进，强调单一数据源、保持状态只读和数据改变只能通过纯函数完成的基本原则</p><p>store</p><p>Context</p><p>React-redux</p><p>connect：连接容器组件和傻瓜组件</p><p>Provider：提供包含store的context</p><p>​    subscribe</p><p>​    dispatch   组成 store</p><p>​    getState</p><h3 id="代码文件的组织方式"><a href="#代码文件的组织方式" class="headerlink" title="代码文件的组织方式"></a>代码文件的组织方式</h3><h5 id="按角色组织"><a href="#按角色组织" class="headerlink" title="按角色组织"></a>按角色组织</h5><p>reducer ：所有redux的reducer</p><p>actions：所有action构造函数</p><p>components:所有傻瓜组件</p><p>containers: 所有容器组件</p><h5 id="按功能组织-Organzied-by-Feature-开发redux应用首选"><a href="#按功能组织-Organzied-by-Feature-开发redux应用首选" class="headerlink" title="按功能组织 (Organzied by Feature) (开发redux应用首选)"></a>按功能组织 (Organzied by Feature) (开发redux应用首选)</h5><p>actionTypes.js定义action类型</p><p>actions.js定义action构造函数，决定这个功能模块可以接受的动作</p><p>views目录，包含这个功能模块中所有的React组件，包括傻瓜组件和容器组件</p><p>index.js这个文件把所有的角色导入然后统一导出</p><h3 id="Store状态树设计"><a href="#Store状态树设计" class="headerlink" title="Store状态树设计"></a>Store状态树设计</h3><p>原则：</p><p>一个模块控制一个状态节点</p><p>避免冗余数据</p><p>树形结构扁平</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;React-相关概念&quot;&gt;&lt;a href=&quot;#React-相关概念&quot; class=&quot;headerlink&quot; title=&quot;React 相关概念&quot;&gt;&lt;/a&gt;React 相关概念&lt;/h3&gt;&lt;p&gt;UI=render(state)&lt;/p&gt;
&lt;p&gt;React理念：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="React" scheme="http://zhoufangy.github.io/categories/React/"/>
    
    
      <category term="Reading notes" scheme="http://zhoufangy.github.io/tags/Reading-notes/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://zhoufangy.github.io/2020/02/26/Redis/"/>
    <id>http://zhoufangy.github.io/2020/02/26/Redis/</id>
    <published>2020-02-26T17:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis相关问题"><a href="#Redis相关问题" class="headerlink" title="Redis相关问题"></a>Redis相关问题</h3><h4 id="缓存与数据一致性问题"><a href="#缓存与数据一致性问题" class="headerlink" title="缓存与数据一致性问题"></a>缓存与数据一致性问题</h4><p>对于既有数据库操作又有缓存操作的接口，一般分为两种执行顺序。</p><ol><li>先操作数据库，再操作缓存。这种情况下如果数据库操作成功，缓存操作失败就会导致缓存和数据库不一致。</li><li>第二种情况就是先操作缓存再操作数据库，这种情况下如果缓存操作成功，数据库操作失败也会导致数据库和缓存不一致。</li></ol><p>大部分情况下，我们的缓存理论上都是需要可以从数据库恢复出来的，所以基本上采取第一种顺序都是不会有问题的。针对那些必须保证数据库和缓存一致的情况，通常是不建议使用缓存的，如果必须使用的话，可以参考<a href="https://www.jianshu.com/p/a532962cb9e9" target="_blank" rel="noopener">这篇文章</a>来解决这个缓解缓存与数据库的一致性问题。</p><h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h4><p>缓存击穿表示恶意用户频繁的模拟请求缓存中不存在的数据，以致这些请求短时间内直接落在了数据库上，导致数据库性能急剧下降，最终影响服务整体的性能。这个在实际项目很容易遇到，如抢购活动、秒杀活动的接口 API 被大量的恶意用户刷，导致短时间内数据库宕机。</p><p>解决方案：</p><ol><li>使用互斥锁排队。当从缓存中获取数据失败时，给当前接口加上锁，从数据库中加载完数据并写入后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。</li><li>使用布隆过滤器。将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及 DB 挂掉。</li></ol><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h4><p>问题：短时间内有大量缓存失效，如果这期间有大量的请求发生同样也有可能导致数据库发生宕机。在 Redis 机群的数据分布算法上如果使用的是传统的 hash 取模算法，在增加或者移除 Redis 节点的时候就会出现大量的缓存临时失效的情形。</p><p>解决方案：</p><ol><li>像解决缓存穿透一样加锁排队。</li><li>建立备份缓存，缓存 A 和缓存 B，A 设置超时时间，B 不设值超时时间，先从 A 读缓存，A 没有读 B，并且更新 A 缓存和 B 缓存。</li><li>计算数据缓存节点的时候采用一致性 hash 算法，这样在节点数量发生改变时不会存在大量的缓存数据需要迁移的情况发生。</li></ol><h4 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h4><p>问题：多个 Redis 客户端同时 set 值引起的并发问题。</p><p>解决方案：把 set 操作放在队列中使其串行化，必须得一个一个执行。</p><h3 id="SpringBoot-整合Redis"><a href="#SpringBoot-整合Redis" class="headerlink" title="SpringBoot 整合Redis"></a>SpringBoot 整合Redis</h3><p>1.创建一个SpringBoot项目</p><p>2.pom添加Redis依赖</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3.application.properties配置Redis参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Redis数据库索引（默认为0）</span><br><span class="line">spring.redis.database=<span class="number">0</span> </span><br><span class="line"># Redis服务器地址</span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># Redis服务器连接端口</span><br><span class="line">spring.redis.port=<span class="number">6379</span> </span><br><span class="line"># Redis服务器连接密码（默认为空）</span><br><span class="line">spring.redis.password=</span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-active=<span class="number">8</span> </span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">spring.redis.pool.max-wait=-<span class="number">1</span> </span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.pool.max-idle=<span class="number">8</span> </span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.pool.min-idle=<span class="number">0</span> </span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">spring.redis.timeout=<span class="number">5000</span></span><br></pre></td></tr></table></figure><p>4.config文件夹下创建RedisConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ZhouFangyuan on 2020-02-24.</span></span><br><span class="line"><span class="comment"> * Time: 20:02</span></span><br><span class="line"><span class="comment"> * Information:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//key采用jackson的序列化方式</span></span><br><span class="line">        template.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(StringRedisTemplate.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 的 spring-boot-starter-data-redis 为 Redis 的相关操作提供了一个高度封装的 <code>RedisTemplate</code> 类，而且对每种类型的数据结构都进行了归类，将同一类型操作封装为 operation 接口。RedisTemplate 对五种数据结构分别定义了操作，如下所示：</p><ul><li>操作字符串：<code>redisTemplate.opsForValue()</code></li><li>操作 <code>Hash：redisTemplate.opsForHash()</code></li><li>操作 <code>List：redisTemplate.opsForList()</code></li><li>操作 <code>Set：redisTemplate.opsForSet()</code></li><li>操作 <code>ZSet：redisTemplate.opsForZSet()</code></li></ul><p>但是对于 string 类型的数据，SpringBoot 还专门提供了 <code>StringRedisTemplate</code> 类，而且官方也建议使用该类来操作 String 类型的数据。那么它和 <code>RedisTemplate</code> 又有啥区别呢？</p><ol><li><code>RedisTemplate</code> 是一个泛型类，而 <code>StringRedisTemplate</code> 不是，后者只能对键和值都为 <code>String</code> 类型的数据进行操作，而前者则可以操作任何类型。</li><li>两者的数据是不共通的，<code>StringRedisTemplate</code> 只能管理 <code>StringRedisTemplate</code> 里面的数据，<code>RedisTemplate</code> 只能管理 <code>RedisTemplate</code> 中 的数据。</li></ol><p>参考资料：<a href="https://www.ibm.com/developerworks/cn/java/know-redis-and-use-it-in-springboot-projects/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/know-redis-and-use-it-in-springboot-projects/index.html</a></p><h3 id="Redis-分布式锁实现"><a href="#Redis-分布式锁实现" class="headerlink" title="Redis 分布式锁实现"></a>Redis 分布式锁实现</h3><p>加锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 释放分布式锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">      Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://xiaozhuanlan.com/topic/4672859130" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/4672859130</a></p><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis相关问题&quot;&gt;&lt;a href=&quot;#Redis相关问题&quot; class=&quot;headerlink&quot; title=&quot;Redis相关问题&quot;&gt;&lt;/a&gt;Redis相关问题&lt;/h3&gt;&lt;h4 id=&quot;缓存与数据一致性问题&quot;&gt;&lt;a href=&quot;#缓存与数据一致性问题&quot; cla
      
    
    </summary>
    
      <category term="Redis" scheme="http://zhoufangy.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>maven</title>
    <link href="http://zhoufangy.github.io/2020/02/24/maven-1/"/>
    <id>http://zhoufangy.github.io/2020/02/24/maven-1/</id>
    <published>2020-02-24T18:39:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre><code>clean install -X</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;clean install -X
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
      <category term="maven" scheme="http://zhoufangy.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Introduce</title>
    <link href="http://zhoufangy.github.io/2020/02/21/Introduce/"/>
    <id>http://zhoufangy.github.io/2020/02/21/Introduce/</id>
    <published>2020-02-21T16:18:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon! </p><p>It’s really my honor to have this opportunity for this interview. </p><p>First let me introduce myself. I’m Fangyuan Zhou, I currently live in Shanghai. I was born in 1992. I like reading at my free time. and I like challenge myself like skidiving. But I’ll never do it again. And my hometown is Changde, the city of Hunan province. And I graduated from Hunan normal University Shuda college in 2014. My major is Computer Science and Technology, I had five years full-time work experience in two Shenzhen companies. then I went to Ireland for learning Engish, During this period of time I had Three months part-time work experience in a Hangzhou company. and travel alone 11 countries.</p><p>I worked for aisidi company as a Engineer from 2014 to 2016 for Yihaoji B2B website.</p><p>I worked for Hundsun Technologies Inc. as a Engineer from 2016 to 2018. I had three projets. First one is Guohai Securities Office Management Platform. It’s an OA project . Secound one is Cockpit, Cockpit is an analysis system based on Big Data.<br>Last one is GF Securities logging streaming system. It’s an analysis platform for logging streaming. During this period of time I spent free time to leaning and got Project Management Professional certificate.</p><p>I worked for Hangzhou YIRU TECHNOLOGIES. as a part time Engineer from 2018 to 2019. My major project is Alora Valley. It’s an e-business system based on WeChat. I was responsible for design and development of some functional modules.</p><p>I’m a quick learner and a good team player. I’m good at communicating with players. </p><p>That’s all, thanks </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Good afternoon! &lt;/p&gt;
&lt;p&gt;It’s really my honor to have this opportunity for this interview. &lt;/p&gt;
&lt;p&gt;First let me introduce myself. I’m Fang
      
    
    </summary>
    
    
      <category term="Introduce" scheme="http://zhoufangy.github.io/tags/Introduce/"/>
    
  </entry>
  
  <entry>
    <title>版本控制</title>
    <link href="http://zhoufangy.github.io/2020/02/20/git/"/>
    <id>http://zhoufangy.github.io/2020/02/20/git/</id>
    <published>2020-02-20T20:15:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>###</p><h1 id="Git和Svn区别"><a href="#Git和Svn区别" class="headerlink" title="Git和Svn区别"></a>Git和Svn区别</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;p&gt;###&lt;/p&gt;
&lt;h1 id=&quot;Git和Svn区别&quot;&gt;&lt;a href=&quot;#Git和Svn区别&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="git" scheme="http://zhoufangy.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://zhoufangy.github.io/2020/02/20/Kafka/"/>
    <id>http://zhoufangy.github.io/2020/02/20/Kafka/</id>
    <published>2020-02-20T18:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="interview" scheme="http://zhoufangy.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>BA</title>
    <link href="http://zhoufangy.github.io/2020/02/20/BA/"/>
    <id>http://zhoufangy.github.io/2020/02/20/BA/</id>
    <published>2020-02-20T17:58:27.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon! </p><p>It’s really my honor to have this opportunity for this interview. </p><p>First let me introduce myself. I’m Fangyuan Zhou, I currently live in Shanghai. I was born in 1992. I like reading at my free time. and I like challenge myself like skidiving. But I’ll never do it again. And my hometown is Changde, the city of Hunan province. And I graduated from Hunan normal University Shuda college in 2014. My major is Computer Science and Technology, I had five years full-time work experience in two Shenzhen companies. then I went to Ireland for learning Engish, During this period of time I had Three months part-time work experience in a Hangzhou company. and travel alone 11 countries.</p><p>I worked for aisidi company as a programmer from 2014 to 2016 for Yihaoji B2B website.then</p><p>I worked for Hundsun Technologies Inc. as a programmer from 2016 to 2018. I had three projets. First one is Guohai Securities Office Management Platform. It’s an OA project . Secound one is Cockpit, Cockpit is an analysis system based on Big Data.<br>Last one is GF Securities logging streaming system. It’s an analysis platform for logging streaming. During this period of time I spent free time to leaning and got Project Management Professional certificate.</p><p>I worked for Hangzhou YIRU TECHNOLOGIES. as a part time programmer from 2018 to 2019. My major project is Alora Valley. It’s an e-business system based on WeChat. I was responsible for design and development of some functional modules.</p><p>I’m not a traditional programmer, most of time I need do some extra work ,for example I created Product Requirements Document for the GF Securities logging streaming system. and I created flow chart for Guohai projects and GF project  like  UML E-R diagrams. to help people understand well.</p><p>I had been used some tools for manage like 禅道 、Confluence，and some for design like 墨刀、ProcessOn</p><p>I’m a quick learner and a good team player. I’m good at communicating with players. </p><p>That’s all, thanks 。</p><p>项目管理工具</p><p>Jira Confluence 禅道 flow chart</p><p>trello </p><p>visio ProcessOn</p><p>FineReport etl ssii ssiar</p><p> sql</p><p>disborad cratcle</p><p>Shell </p><p>Business requirements document x</p><p>function design document </p><p>sRS document </p><p>Product Requirements Document  墨刀</p><p>user story maps</p><p>UML diagrams E-R图</p><p>BABok</p><p>llb website</p><p>jony BI ATL sql</p><p>tsql</p><p>Sql </p><p>mysql</p><p>It’s right to become a BA?</p><p>1.natural curiosity  Water Color Pen</p><p>2.dissatisfied until you understand.  want dig deeper </p><p>3.I always helping people to find a solution. My husband ‘s  Muse </p><p>4.fact-based material</p><p>5.be able to write</p><p>6.can take a lot of different varying information and some house narrow down to me to make sense and then explain that to somebody else</p><p>7.don’t have to be an extrovert , you just have to be sociable and be willing to talk to strangers </p><p>8.confortable for the change</p><p>9.ambiguity</p><p>SDLC</p><p>planning phase - requirements  you undersell the clients try to build and purpose of it,</p><p>You having to find the stakeholder</p><p>Planning and Requirement Analysis</p><p>Defining Requirements</p><p>Designing the Product Architecture</p><p>Building or Developing the Product</p><p>Testing the Product</p><p>Deployment in the Market and Maintenance</p><p>SDLC model</p><ul><li>Waterfall Model</li><li>Iterative Model 迭代模型</li><li>Agile Model 敏捷</li><li>Spiral Model</li><li>V-Model</li><li>Big Bang Model</li></ul><p>FCA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Good afternoon! &lt;/p&gt;
&lt;p&gt;It’s really my honor to have this opportunity for this interview. &lt;/p&gt;
&lt;p&gt;First let me introduce myself. I’m Fang
      
    
    </summary>
    
      <category term="interview" scheme="http://zhoufangy.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://zhoufangy.github.io/2020/02/20/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhoufangy.github.io/2020/02/20/Java基础/</id>
    <published>2020-02-20T17:50:52.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String,StringBuilder,StringBuffer"></a>String,StringBuilder,StringBuffer</h4><table><thead><tr><th>区别</th><th>可变性</th><th>线程安全性</th><th>性能</th></tr></thead><tbody><tr><td>String</td><td>X</td><td>√</td><td></td></tr><tr><td>StringBuffer</td><td>√</td><td>√同步锁</td><td></td></tr><tr><td>StringBuilder</td><td>√</td><td>X</td><td>比StringBuffer10%-15%的提升</td></tr></tbody></table><p>总结：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.操作少量的数据，使用String</span><br><span class="line">2.单线程下操作大量数据，适用StringBuilder</span><br><span class="line">3.多线程下操作大量数据，StringBuffer</span><br></pre></td></tr></table></figure><h4 id="equals和-区别"><a href="#equals和-区别" class="headerlink" title="equals和==区别"></a>equals和==区别</h4><p>==对与基本类型来说是值比较，对与引用类型来说比较的是引用，而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把它变成了值比较，所以一般情况下equals比较的是值是否相等。        </p><h4 id="重写equals一定要重写hashcode方法吗？为什么？"><a href="#重写equals一定要重写hashcode方法吗？为什么？" class="headerlink" title="重写equals一定要重写hashcode方法吗？为什么？"></a>重写equals一定要重写hashcode方法吗？为什么？</h4><p>重写equals一定要重写hashcode方法，否则程序无法正常运行，hashcode()方法必须遵从Object规范。相等的对象必须具有相等的hash code。</p><h4 id="hashcode方法有什么作用"><a href="#hashcode方法有什么作用" class="headerlink" title="hashcode方法有什么作用?"></a>hashcode方法有什么作用?</h4><p>hashcode的存在主要用于提高查找效率，先进行hashcode比较，如果不同，就没必要进行equals比较了，这样就大大较少了，equals比较的次数，当比较大量数据时效率就显著提高了。比如在集合中的使用。</p><h3 id="一致性哈希-和哈希结果对10取模有什么区别吗"><a href="#一致性哈希-和哈希结果对10取模有什么区别吗" class="headerlink" title="一致性哈希 和哈希结果对10取模有什么区别吗"></a>一致性哈希 和哈希结果对10取模有什么区别吗</h3><p>如果增加或删除机器时（N变化）代价会很高，所有的数据都不得不根据id重新计算一遍哈希值，并将哈希值对新的机器数进行取模。然后进行大规模的数据迁移。为了解决这些问题引入一致性哈希，我们假设数据的id通过哈希函数转换成的哈希值范围是2^32，也就是0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形，那么一个数据id在计算出哈希值之后认为对应到环中的一个位置上机器在环中的位置根据机器id（主机名或者主机IP，是主机唯一的就行）设计算出的哈希值对2^32取模对应到环上。那么一条数据如何确定归属哪台机器呢？我们可以在该数据对应环上的位置顺时针寻找离该位置最近的机器，将数据归属于该机器上…</p><h3 id="实现这样一种高效插入、查找的有序集合，你会怎么做"><a href="#实现这样一种高效插入、查找的有序集合，你会怎么做" class="headerlink" title="实现这样一种高效插入、查找的有序集合，你会怎么做"></a>实现这样一种高效插入、查找的有序集合，你会怎么做</h3><p>我：我觉得对应一种数据结构吧，是什么来着……额……，就是一种数据结构，它的任意棵子树的头结点数值大于左子树的小于右子树的（没想起来是二叉搜索树，好笨），然后这样的话插入和查找的效率都是log(2,N)了</p><h3 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1.面向对象和面向过程"></a>1.面向对象和面向过程</h3><pre><code>面向过程性能更高，但是面向对象易维护、易复用、易扩展</code></pre><h3 id="2-java语言有哪些特点"><a href="#2-java语言有哪些特点" class="headerlink" title="2.java语言有哪些特点"></a>2.java语言有哪些特点</h3><pre><code>面向对象（封装，集成，多态）平台无关 可靠性 安全性 支持多线程</code></pre><h3 id="3-JVM、JDK、JRE"><a href="#3-JVM、JDK、JRE" class="headerlink" title="3.JVM、JDK、JRE"></a>3.JVM、JDK、JRE</h3><pre><code>JVM 虚拟机JDK java SDKJRE java 运行时环境.java文件 --jdk中javac编译-&gt; .class文件（生成JVM可以理解的Java字节）--JVM--&gt;机器可以执行的二进制机器码</code></pre><h3 id="4-OracleJDK-和OpenJDK对比"><a href="#4-OracleJDK-和OpenJDK对比" class="headerlink" title="4.OracleJDK 和OpenJDK对比"></a>4.OracleJDK 和OpenJDK对比</h3><pre><code>OpenJDK是开源的参考模型，OracleJDK是它的一个实现，不是完全开源的OracleJDK比OpenJDK更稳定性能更好许可协议OracleJDK二进制代码获得许可OpenJDKGPL v2获得</code></pre><h3 id="5-Java和C-的区别"><a href="#5-Java和C-的区别" class="headerlink" title="5.Java和C++的区别"></a>5.Java和C++的区别</h3><h3 id="6-什么是Java程序的主类？应用程序和小程序的主类有和不同"><a href="#6-什么是Java程序的主类？应用程序和小程序的主类有和不同" class="headerlink" title="6.什么是Java程序的主类？应用程序和小程序的主类有和不同"></a>6.什么是Java程序的主类？应用程序和小程序的主类有和不同</h3><h3 id="7-Java应用程序与小程序之间差别"><a href="#7-Java应用程序与小程序之间差别" class="headerlink" title="7.Java应用程序与小程序之间差别"></a>7.Java应用程序与小程序之间差别</h3><h3 id="8-字符型常量和字符串常量的区别"><a href="#8-字符型常量和字符串常量的区别" class="headerlink" title="8.字符型常量和字符串常量的区别"></a>8.字符型常量和字符串常量的区别</h3><pre><code>形式上：‘’ “”含义上：字符常量相当于一个整型值，字符串常量指地址值内存大小不同，字符常量占2个字节，字符串占若干个</code></pre><h3 id="9-构造器Constructor是否可以被Override？"><a href="#9-构造器Constructor是否可以被Override？" class="headerlink" title="9.构造器Constructor是否可以被Override？"></a>9.构造器Constructor是否可以被Override？</h3><pre><code>Constructor不可以被继承，所以不能被重写，但可以被overLoad。</code></pre><h3 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10.重载和重写的区别"></a>10.重载和重写的区别</h3><pre><code>重载Add(String a)Add(String a,int b)Add(int a, String b)重写父类Private方法不能被重写public String add（String a， String b）{}子类@Override (作用范围小于等于父类)public String add（String a， String b）{}</code></pre><h3 id="11-Java面向对象编程三大特性"><a href="#11-Java面向对象编程三大特性" class="headerlink" title="11.Java面向对象编程三大特性"></a>11.Java面向对象编程三大特性</h3><pre><code>封装：对象属性私有化，开放部分属性供外界访问继承：继承父类多态：程序引用变量方法调用在编程时不确定，运行期间才确定实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</code></pre><h3 id="12-String-Stringbuffer-Stringbuilder的区别？String为什么是不可变的？"><a href="#12-String-Stringbuffer-Stringbuilder的区别？String为什么是不可变的？" class="headerlink" title="12.String Stringbuffer Stringbuilder的区别？String为什么是不可变的？"></a>12.String Stringbuffer Stringbuilder的区别？String为什么是不可变的？</h3><pre><code>区别           可变性  线程安全性  性能 String           ×       √         StringBuffer     √       √同步锁    StringBuilder    √       ×          比StringBuffer10%-15%提升1.操作少量的数据，使用String2.单线程下操作大量数据，适用StringBuilder3.多线程下操作大量数据，StringBuffer</code></pre><h3 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13.自动装箱与拆箱"></a>13.自动装箱与拆箱</h3><pre><code>装箱：将基本类型用他们对应的引用类型包装起来拆箱：将包装类型转换为基本数据类型</code></pre><h3 id="14-在静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14.在静态方法内调用一个非静态成员为什么是非法的"></a>14.在静态方法内调用一个非静态成员为什么是非法的</h3><pre><code>静态方法里不能调用其他非静态变量，也不可以访问非静态变量成员。</code></pre><h3 id="15-在JAVA中定义一个不做事且没有参数的构造方法的作用。"><a href="#15-在JAVA中定义一个不做事且没有参数的构造方法的作用。" class="headerlink" title="15.在JAVA中定义一个不做事且没有参数的构造方法的作用。"></a>15.在JAVA中定义一个不做事且没有参数的构造方法的作用。</h3><pre><code>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 　</code></pre><h3 id="16-import-java和javax有什么区别？"><a href="#16-import-java和javax有什么区别？" class="headerlink" title="16.import java和javax有什么区别？"></a>16.import java和javax有什么区别？</h3><pre><code>实际上java和javax没有区别。这都是一个名字。</code></pre><h3 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17.接口和抽象类的区别是什么？"></a>17.接口和抽象类的区别是什么？</h3><pre><code>1.接口默认方法是public。所有方法在接口中不能有实现，而抽象类可以有非抽象方法2.接口中除了static、final变量，不能有其他变量，而抽象类中不一定3.一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口4.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写，所以不能使用private）5.从设计层面来讲，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范。</code></pre><h3 id="18-成员变量与局部变量的区别？"><a href="#18-成员变量与局部变量的区别？" class="headerlink" title="18.成员变量与局部变量的区别？"></a>18.成员变量与局部变量的区别？</h3><pre><code>1.语法形式上，成员变量是属于类的，局部变量是在方法中定义的变量或是方法的参数。成员变量可以被public、private、static等修饰，而局部变量不能被访问控制修饰符以及static修饰，但是成员变量和局部变量都能被final修饰。2.存储方式上,成员变量使用static修饰，那么这个成员变量是属于类的，如果没有static修饰，则属于实例的，而对象存在于堆内存，局部变量存在于占内存。3.生存时间上，成员变量是对象的一部分，随对象的创建而存在，局部变量随方法的调用而自动消失4.成员变量如果没有赋初值，会自动以类型的默认值而赋值（final修饰的成员变量也必须显式赋值），局部变量不会自动赋值。</code></pre><h3 id="19。创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19。创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19。创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>19。创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><pre><code>newnew创建对象实例，对象实例在堆内存，对象引用指向对象实例，对象引用在栈内存。</code></pre><h3 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h3><pre><code>返回值的作用:接收出结果，使得它可以用于其他的操作！</code></pre><h3 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h3><pre><code>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</code></pre><h3 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h3><pre><code>1.名字与类名相同。2.没有返回值，但不能用void声明构造函数。3.生成类的对象时自动执行，无需调用。</code></pre><h3 id="23-静态方法和实例方法有何不同"><a href="#23-静态方法和实例方法有何不同" class="headerlink" title="23. 静态方法和实例方法有何不同"></a>23. 静态方法和实例方法有何不同</h3><pre><code>在外部调用静态方法时，可以使用&quot;类名.方法名&quot;的方式，也可以使用&quot;对象名.方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</code></pre><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;String-StringBuilder-StringBuffer&quot;&gt;&lt;a href=&quot;#String-StringBuilder-StringBuffer&quot; class=&quot;headerlink&quot; title=&quot;String,StringBuilder,Strin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://zhoufangy.github.io/2020/02/20/JVM/"/>
    <id>http://zhoufangy.github.io/2020/02/20/JVM/</id>
    <published>2020-02-20T00:07:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><p>主要包含了PC寄存器（程序计数器）、Java虚拟机栈、本地方法栈、Java堆、方法区以及运行时常量池。</p><p>JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcrt47dw8qj310i0o67kd.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcrc2dihs6j310u0j8gvt.jpg" alt=""></p><h6 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h6><p>当前线程所指向的字节码的行号指示器，会指出下一条将要指向指令的地址，线程私有，不会出现OutOfMemoryError。</p><h6 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h6><p>是为虚拟机执行Java方法服务，是线程私有的，在线程创建时会被创建，每个方法在执行的同时都会创建一个 栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>一般所谓的“栈”，指的是虚拟机栈中局部变量表部分，其中存放了各种基本数据类型( <code>8</code> 种)，对象引用(<code>reference</code> 类型) 和 <code>returnAddress</code> 类型。局部变量表所需的空间在编译期就已经确定并完成分配，在方法运行期间不会被改变。</p><p><code>Java</code> 虚拟栈中可能出现两种异常：</p><ul><li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度</li><li><code>OutOfMemoryError</code>：虚拟机栈扩展时无法申请到足够的内存</li></ul><h6 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h6><p>是为虚拟机执行Native方法服务，可能会抛出StackOverflowError or OutOfMemoryError。</p><h6 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h6><p>虚拟机中最主要的内存区域，是线程共享的，在虚拟机启动时创建，几乎所有的对象实例都存储在Java堆中。</p><p>Java堆也被称作GC堆。从内存回收角度看，可以分为新生代和老年代。新生代有可以分为Eden区、From Survivor区，To Survivor区等。</p><p>Java堆的实现既可以实现为固定的，也可以是扩展的，可以通过-Xmx和-Xms来控制堆的大小。</p><p>如果堆中没有内存并且也无法再扩展时，会抛出OutOfMemoryError。</p><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><p>也是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。也叫做Non-Heap。</p><p>如果方法去无法满足内存分配需求，会抛出OutOfMemoryError。</p><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>是方法区的一部分，Class文件中的常量池用于编译期生成的各种字面量和符号引用，这部分内容在类加载后被存入运行时常量池。</p><p>运行时常量池受到方法区内存的限制，如果常量池无法再申请内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><p>直接内存并不由 <code>JVM</code> 管理，它是利用 <code>Native</code> 函数库在 <code>Java</code> 堆外申请分配的内存区域，可以避免在 <code>Java</code> 堆和 <code>Native</code> 堆中复制数据以提高性能。</p><p>例如 <code>NIO</code> 中的 <code>DirectByteBuffer</code> 就可以作为这块内存的引用进行操作直接内存。</p><h6 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h6><p>有时会看到方法区被称为永久代，其实两者有着本质的区别。方法区是 <code>JVM</code> 规范中的定义，而永久代是 <code>JVM</code> 规范的一种实现，并且只有在 <code>HotSpot</code> 虚拟机中如此，其他虚拟机中没有永久代的说法。</p><p>在 <code>JDK1.6</code> 之前，<code>HotSpot</code> 虚拟机把 <code>GC</code> 分代收集扩展至方法区，或者说使用永久代实现方法区。不过永久代有 <code>-XX:MaxPermSize</code> 的上限，很容易遇到内存溢出问题。</p><p>所以在 <code>JDK1.7</code> 中，将部分数据已经转移 <code>Java Heap</code> 或 <code>Native Heap</code> 中，例如：将原本放在永久代中的字符串池和类的静态变量移出到 <code>Java Heap</code> 中，将符号引用转移到 <code>Native Heap</code> 中。但永久代仍然存在，并没有移除。</p><p>在 <code>JDK1.8</code> 中，取消了永久代，代替为元空间实现，它也是 <code>JVM</code> 规范中方法区的一种实现。不过它与永久代最大的不同是：元空间并不在虚拟机中，而是将元空间放到本地内存中。所以默认情况下，它只受本地内存的限制，可以通过 <code>-XX:MetaspaceSize</code> 参数设置初始空间大小，默认没有最大空间限制。</p><h4 id="常见的-OOM-及原因"><a href="#常见的-OOM-及原因" class="headerlink" title="常见的 OOM 及原因"></a>常见的 OOM 及原因</h4><p>OOM：java.lang.OutOfMemoryError</p><p><strong>java.lang.OutOfMemoryError:Java heap space</strong></p><ul><li>流量访问量大，超过设置的堆空间大小；</li><li>内存泄露，不能被回收的对象消耗过多堆空间；</li></ul><p><strong>java.lang.OutOfMemoryError:Permgen space</strong></p><p>在 <code>JDK7</code> 中，<code>HotSpot</code> 虚拟机使用永久代实现方法区，永久代较小，而且回收效率较低，很容易出现内存溢出。</p><p>因此，<code>JDK8</code> 取消了永久代，使用元空间来实现方法区，存放在本地内存中。</p><p><strong>java.lang.OutOfMemoryError:Metaspace</strong></p><p>引起元数据区空间不足的原因主要有：</p><ul><li>加载的类太多，常见于 <code>jsp</code> 页面过多时；</li><li>元空间被实现在堆外，主要受到进程本身的内存限制，一般很难出现溢出。</li></ul><h4 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h4><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><h4 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h4><p>**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><h4 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h4><p><strong>原子性：</strong>使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性：</strong> Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都用CAS从主内存刷新。因此，可以使用<code>volatile</code>来保证多线程操作时变量的可见性。除了<code>volatile</code>，Java中的<code>synchronized</code>和<code>final</code>两个关键字也可以实现可见性。只不过实现方式不同。</p><p> volatile  通过内存屏障<br> synchronized 通过修饰的程序段同一时间只能由同一线程运行，释放锁前会刷新到主内存</p><p><strong>有序性：</strong>在Java中，可以使用<code>synchronized</code>和<code>volatile</code>来保证多线程之间操作的有序性。</p><p>但是<code>synchronized</code>是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p><h4 id="JVM-为什么survivor需要有2个。"><a href="#JVM-为什么survivor需要有2个。" class="headerlink" title="JVM,为什么survivor需要有2个。"></a>JVM,为什么survivor需要有2个。</h4><p>survivor需要2个，主要是为了规避内存碎片化</p><h4 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h4><h6 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h6><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><p>单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在<strong>缓存一致性问题</strong>，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><h6 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h6><h6 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h6><p>原子性问题，可见性问题和有序性问题。</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h4 id="JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VS Java对象模型"></a>JVM内存结构 VS Java内存模型 VS Java对象模型</h4><p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。</p><p>JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p><p>Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。正是由于有了JMM，Java的并发编程才能避免很多问题。</p><p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p><h4 id="Java对象的内存分配过程是如何保证线程安全的？"><a href="#Java对象的内存分配过程是如何保证线程安全的？" class="headerlink" title="Java对象的内存分配过程是如何保证线程安全的？"></a>Java对象的内存分配过程是如何保证线程安全的？</h4><p><strong>为了保证对象的内存分配过程中的线程安全性，HotSpot虚拟机提供了一种叫做TLAB(Thread Local Allocation Buffer)的技术。</strong></p><p>在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。</p><p><strong>所以，“堆是线程共享的内存区域”这句话并不完全正确，因为TLAB是堆内存的一部分，他在读取上确实是线程共享的，但是在内存分分配上，是线程独享的。</strong></p><p>对象的内存分配步骤就是先尝试TLAB分配，但是TLAB空间其实不大，当空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配。</p><h4 id="不同的虚拟机在实现运行时内存的时候有什么区别？"><a href="#不同的虚拟机在实现运行时内存的时候有什么区别？" class="headerlink" title="不同的虚拟机在实现运行时内存的时候有什么区别？"></a>不同的虚拟机在实现运行时内存的时候有什么区别？</h4><p>虚拟机规范对方法区实现的位置并没有明确要求，在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。所以，这时候方法区也是可以被垃圾回收的。</p><blockquote><p>JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分位新生代、老年代和永久代。</p></blockquote><p>在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p><h4 id="运行时数据区中哪些区域是线程共享的？哪些是独享的？"><a href="#运行时数据区中哪些区域是线程共享的？哪些是独享的？" class="headerlink" title="运行时数据区中哪些区域是线程共享的？哪些是独享的？"></a>运行时数据区中哪些区域是线程共享的？哪些是独享的？</h4><p>在JVM运行时内存区域中，PC寄存器、虚拟机栈和本地方法栈是线程独享的。</p><p>而Java堆、方法区是线程共享的。但是值得注意的是，Java堆其实还为每一个线程单独分配了一块<a href="http://www.hollischuang.com/archives/3855" target="_blank" rel="noopener">TLAB空间</a>，这部分空间在分配时是线程独享的，在使用时是线程共享的。</p><h4 id="除了JVM运行时内存以外，还有什么区域可以用吗？"><a href="#除了JVM运行时内存以外，还有什么区域可以用吗？" class="headerlink" title="除了JVM运行时内存以外，还有什么区域可以用吗？"></a>除了JVM运行时内存以外，还有什么区域可以用吗？</h4><p>直接内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响。可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。</p><h4 id="堆和栈的区别是什么？"><a href="#堆和栈的区别是什么？" class="headerlink" title="堆和栈的区别是什么？"></a>堆和栈的区别是什么？</h4><p>堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同：</p><p>堆中主要存放对象实例。<br>栈（局部变量表）中主要存放各种基本数据类型、对象的引用。</p><p>堆内存是线程共享的，栈内存是线程私有的；</p><p>堆内存用来存放由new创建的对象和数组，栈内存中存放一些基本类型的变量和对象的引用变量</p><h4 id="Java中的数组是存储在堆上还是栈上的？"><a href="#Java中的数组是存储在堆上还是栈上的？" class="headerlink" title="Java中的数组是存储在堆上还是栈上的？"></a>Java中的数组是存储在堆上还是栈上的？</h4><p>在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p><p>所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。</p><h4 id="Java中的对象创建有多少种方式？"><a href="#Java中的对象创建有多少种方式？" class="headerlink" title="Java中的对象创建有多少种方式？"></a>Java中的对象创建有多少种方式？</h4><p>Java中有很多方式可以创建一个对象，最简单的方式就是使用new关键字。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = new User();</span><br></pre></td></tr></table></figure><p>除此以外，还可以使用反射机制创建对象：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user = User.class.newInstance();</span><br></pre></td></tr></table></figure><p>或者使用Constructor类的newInstance：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>除此之外还可以使用clone方法和反序列化的方式，这两种方式不常用并且代码比较复杂。</p><h4 id="Java中对象创建的过程是怎么样的？"><a href="#Java中对象创建的过程是怎么样的？" class="headerlink" title="Java中对象创建的过程是怎么样的？"></a>Java中对象创建的过程是怎么样的？</h4><p>对于一个普通的Java对象的创建，大致过程如下：</p><p>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。<br>2、检查符号引用代表的类是否被加载、解析、初始化过。<br>3、虚拟机为对象分配内存。<br>4、虚拟机将分配到的内存空间都初始化为零值。<br>5、虚拟机对对象进行必要的设置。<br>6、执行方法，成员变量进行初始化</p><h4 id="Java中的对象一定在堆上分配内存吗？"><a href="#Java中的对象一定在堆上分配内存吗？" class="headerlink" title="Java中的对象一定在堆上分配内存吗？"></a>Java中的对象一定在堆上分配内存吗？</h4><p>Java堆中主要保存了对象实例，但是也不是绝对，编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，比如逃逸分析。如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcrm2cm84jj31140u07iz.jpg" alt=""></p><h4 id="如何获取堆和栈的dump文件？"><a href="#如何获取堆和栈的dump文件？" class="headerlink" title="如何获取堆和栈的dump文件？"></a>如何获取堆和栈的dump文件？</h4><p>Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><p>可以使用在服务器上使用<a href="http://www.hollischuang.com/archives/303" target="_blank" rel="noopener">jmap</a>命令来获取堆dump，使用<a href="http://www.hollischuang.com/archives/110" target="_blank" rel="noopener">jstack</a>命令来获取线程的调用栈dump。</p><h4 id="JVM三大性能调优参数，JVM-几个重要的参数"><a href="#JVM三大性能调优参数，JVM-几个重要的参数" class="headerlink" title="JVM三大性能调优参数，JVM 几个重要的参数"></a>JVM三大性能调优参数，JVM 几个重要的参数</h4><p><strong>-Xms:设置初始分配大小，默认为物理内存的“1/64”</strong></p><p><strong>-Xmx:最大分配内存，默认为物理内存的“1/4”</strong></p><p><strong>-Xss规定了每个线程堆栈的大小。一般情况下256K是足够了。影响了此进程中并发线程数大小。</strong></p><p>在很多情况下，-Xms和-Xmx设置成一样的。这么设置，是因为当Heap不够用时，会发生内存抖动，影响程序运行稳定性。</p><h4 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h4><h5 id="何时进行JVM调优"><a href="#何时进行JVM调优" class="headerlink" title="何时进行JVM调优"></a>何时进行JVM调优</h5><ul><li>Heap内存（老年代）持续上涨达到设置的最大内存值； </li><li>Full GC 次数频繁； </li><li>GC 停顿时间过长（超过1秒）； </li><li>应用出现OutOfMemory 等内存异常； </li><li>应用中有使用本地缓存且占用大量内存空间； </li><li>系统吞吐量与响应性能不高或下降。</li></ul><h5 id="JVM调优的基本原则"><a href="#JVM调优的基本原则" class="headerlink" title="JVM调优的基本原则"></a>JVM调优的基本原则</h5><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：</p><ul><li>大多数的Java应用不需要进行JVM优化； </li><li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）； </li><li>上线之前，应先考虑将机器的JVM参数设置到最优； </li><li>减少创建对象的数量（代码层面）； </li><li>减少使用全局变量和大对象（代码层面）； </li><li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）； </li><li>分析GC情况优化代码比优化JVM参数更好（代码层面）； </li></ul><h5 id="JVM调优可通过以下步骤进行："><a href="#JVM调优可通过以下步骤进行：" class="headerlink" title="JVM调优可通过以下步骤进行："></a>JVM调优可通过以下步骤进行：</h5><ul><li>使用GCViewer日志分析工具分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点； </li><li>确定JVM调优量化目标； </li><li>确定JVM调优参数（根据历史JVM参数来调整）； </li><li>依次调优内存、延迟、吞吐量等指标； </li><li>对比观察调优前后的差异； </li><li>不断的分析和调整，直到找到合适的JVM参数配置； </li><li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li></ul><h4 id="JVM内存管理"><a href="#JVM内存管理" class="headerlink" title="JVM内存管理"></a>JVM内存管理</h4><p>Java内存管理采用的是自动内存管理机制，具体来讲是内存分配和内存回收。</p><h4 id="JVM的常见的垃圾收集器"><a href="#JVM的常见的垃圾收集器" class="headerlink" title="JVM的常见的垃圾收集器"></a>JVM的常见的垃圾收集器</h4><p>Serial Collector 串行收集器</p><p>Parallel Collector 并行收集器</p><p>CMS 并发收集器 用于老年代, 采用标记-清除算法</p><p>Ｇ１垃圾收集器主要针对多核处理器和大内存的服务器, 同时还能保证高吞吐量. </p><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p><strong>Java垃圾回收器是一种自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器</strong></p><p><a href="http://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2509</a></p><h4 id="Minor-GC-，Full-GC-触发条件"><a href="#Minor-GC-，Full-GC-触发条件" class="headerlink" title="Minor GC ，Full GC 触发条件"></a>Minor GC ，Full GC 触发条件</h4><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p>又叫Minor GC(次收集), Young GC经常发生, 且其每次消耗的时间较短.</p><p>—— <strong>它只对Young Generation中的对象进行垃圾收集</strong>.</p><p><strong>触发条件:</strong></p><p>在Young Generation(新生代)的Eden区的空间不足以容纳新生成的对象时执行, 同时会将 Eden 区与 From Survivor 区中尚且存活的对象移动至空闲的 To Survivor 区中.</p><p>—— 程序运行过程中, <strong>始终有一个 Survivor 区是完全处于空闲状态的</strong>, 如果不是, 说明应用程序出现故障了.</p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>又叫Major GC(主收集), 是<strong>对整个Java Heap中的对象(不包括永久代/元空间)进行垃圾收集</strong>.</p><p>Full GC操作耗时久, 对系统的性能影响较大, 因此在 JVM 的调优中, 很多工作是针对 Full GC 的调优 —— 要尽可能减少Full GC的频率.</p><blockquote><p>Full GC 是一种”昂贵”的垃圾收集方式, 它要对整个Heap进行垃圾收集, 并做一定的空间整理, 这会使Stop-The-World的时间变长.</p></blockquote><p><strong>Full GC的触发条件:</strong></p><blockquote><p>(1) 年老代(Tenured)空间不足:</p><ul><li>通过Minor GC后进入老年代的对象的体积大于老年代的可用空间;</li><li>由Eden块、From Space块向To Space复制存活对象时, 它们的体积大于To Space的大小, 系统就会把这些对象转存到老年代, 而老年代的可用空间小于这些对象的体积.</li></ul><p>(2) <code>System.gc()</code>方法被显式调用, 系统建议执行Full GC, 但并不会立即执行 —— <strong>非常影响程序性能, 建议禁止使用</strong>;</p><p>(3) 上一次GC之后Heap中各个区域空间的动态变化.</p><p> <strong>Full GC 次数过多</strong>，主要有以下两种原因：</p><ul><li><p>代码中一次获取了大量的对象，导致内存溢出，此时可以通过 Eclipse 的 Mat 工具查看内存中有哪些对象比较多。</p></li><li><p>内存占用不高，但是 Full GC 次数还是比较多，此时可能是显示的 System.gc() 调用导致 GC 次数过多，这可以通过添加 -XX:+DisableExplicitGC 来禁用 JVM 对显示 GC 的响应</p><p><strong>CPU 过高</strong></p><p>jstack</p></li></ul></blockquote><h4 id="描述JVM中一次Full-gc过程"><a href="#描述JVM中一次Full-gc过程" class="headerlink" title="描述JVM中一次Full gc过程"></a>描述JVM中一次Full gc过程</h4><h4 id="JVM中类加载机制，类加载过程，什么是双亲委派模型？"><a href="#JVM中类加载机制，类加载过程，什么是双亲委派模型？" class="headerlink" title="JVM中类加载机制，类加载过程，什么是双亲委派模型？"></a>JVM中类加载机制，类加载过程，什么是双亲委派模型？</h4><p><code>Java</code>中的所有类，必须被装载到<code>jvm</code>中才能运行，这个装载工作是由<code>jvm</code>中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中，<code>JVM</code>在加载类的时候，都是通过<code>ClassLoader</code>的<code>loadClass（）</code>方法来加载class的，<code>loadClass</code>使用<strong>双亲委派模式</strong>。</p><p>一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现</p><p><strong>类加载机制：</strong>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。</p><p><strong>类加载过程</strong></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcrt680dqdj30zc0co0zh.jpg" alt=""></p><p>  (1) 装载：查找和导入Class文件；</p><p>  (2) 链接：把类的二进制数据合并到JRE中；</p><pre><code>(a)校验：检查载入Class文件数据的正确性；(b)准备：给类的静态变量分配存储空间；(c)解析：将符号引用转成直接引用；</code></pre><p>  (3) 初始化：对类的静态变量，静态代码块执行初始化操作</p><p><strong>双亲委派模型</strong></p><p>该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p><h4 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些."></a>类加载器有哪些.</h4><p>根类加载器，由C++实现，没有父类。<br>扩展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null<br>应用类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader<br>自定义类加载器，父类加载器肯定为AppClassLoader。</p><p>除了根类加载器之外，其他两个扩展类加载器和应用类加载器都是通过类sun.misc.Launcher进行初始化，而Launcher类则由根类加载器进行加载。</p><h4 id="如何判断是否有内存泄露？"><a href="#如何判断是否有内存泄露？" class="headerlink" title="如何判断是否有内存泄露？"></a>如何判断是否有内存泄露？</h4><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：<br>1）首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；<br>2）其次，这些对象是无用的，即程序以后不会再使用这些对象。<br>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p>jstat [ option vmid [interval[s|ms] [count]] ]查看JVM各种运行状态</p><h4 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h4><p><strong>新生代采用复制算法</strong></p><p>GC回收过程中，当Eden区满时，还存活的对象会被复制到其中一个Survivor区；当回收时，会将Eden和使用的Survivor区还存活的对象，复制到另外一个Survivor区，然后对Eden和用过的Survivor区进行清理。</p><p>如果另外一个Survivor区没有足够的内存存储时，则会进入老年代。</p><p>这里针对哪些对象会进入老年代有这样的机制：对象每经历一次复制，年龄加1，达到晋升年龄阈值后，转移到老年代。</p><p>在这整个过程中，由于Eden中的对象属于像浮萍一样“瞬生瞬灭”的对象，所以并不需要1：1的比例来分配内存，而是采用了8：1：1的比例来分配。</p><p>而针对那些像“水熊虫”一样，历经多次清理依旧存活的对象，则会进入老年代，而老年的清理算法则采用下面要讲到的“标记整理算法”。</p><p><strong>老年代使用标记整理算法</strong></p><p>标记整理（Mark-Compact）算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><strong>分代收集算法</strong></p><p>分代收集算法，基本思路：将Java的堆内存逻辑上分成两块，新生代和老年代，针对不同存活周期、不同大小的对象采取不同的垃圾回收策略。</p><p>而在新生代中大多数对象都是瞬间对象，只有少量对象存活，复制较少对象即可完成清理，因此采用复制算法。而针对老年代中的对象，存活率较高，又没有额外的担保内存，因此采用标记整理算法。</p><p>其实，回头看，分代收集算法就是对新生代和老年代算法从策略维度的规划而已</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcrrvthzbgj311s0pm7gd.jpg" alt=""></p><h4 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h4><p>强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存  浏览器后退按钮</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table><h4 id="Java序列化，有ID和没ID会出现问题吗？"><a href="#Java序列化，有ID和没ID会出现问题吗？" class="headerlink" title="Java序列化，有ID和没ID会出现问题吗？"></a>Java序列化，有ID和没ID会出现问题吗？</h4><p>序列化ID的作用：  </p><p>它决定着是否能够成功反序列化！简单来说，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p><p>序列化ID如何产生：</p><p>当我们一个实体类中没有显示的定义一个名为“serialVersionUID”、类型为long的变量时，Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。譬如，当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败。那么如何解决呢？便是在本地类中添加一个“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。</p><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h3&gt;&lt;h4 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构
      
    
    </summary>
    
      <category term="面试" scheme="http://zhoufangy.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://zhoufangy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://zhoufangy.github.io/2020/02/20/%E9%9D%A2%E8%AF%95/"/>
    <id>http://zhoufangy.github.io/2020/02/20/面试/</id>
    <published>2020-02-20T00:07:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1,自我介绍"></a>1,自我介绍</h1><p>面试官你好，我叫周芳园，来自深圳，毕业于湖南师范大学树达学院计算机科学与技术专业，2014年毕业，毕业后进入深圳爱施德股份有限公司，参与其B2B和F2R电商项目的开发工作，主要负责支付模块开发，第三方支付对接，如易宝支付。                   </p><p>后进入恒生电子股份有限公司深圳研发部，<br>主要做证券公司定制化开发，期间参与国海证券，广发证券相关项目开发以及实施交付。</p><p>第一个项目是国海证券移动综合管理平台<br>这个是一个移动OA项目，为员工提供安全开放的数据服务，挂载在微信公众号、企业微信、钉钉等多平台<br>我负责核心服务的开发，微信钉钉平台同步与兼容，中控设计与开发，分布式服务器搭建以及代码部署和运维管理。技术选型为：OpenAPI+ oauth2网管授权+Spring + Redis+couchbase、mysql、tomcat+light。中台整合采用AntDesign+Springboot+mysql</p><p>难点：内网隔离，外网访问问题。 一键脚本部署，</p><p>开发问题，搭建gogs 作为私有git代码管理器。使用nexus搭建自有maven仓库。</p><p>业务方面：</p><p>vpn方案改造。原来的方案VPN+鉴权，用户需要登录两次，改造后仅需登录一次，即可完成登录。</p><p>https 数据加密 手势登录 强制下线</p><p>— shadowrocket 代理内网。</p><p>第二个项目是国海证券领导驾驶舱<br>领导驾驶舱是基于FineReport生成报表后展示给管理层的<strong>dashboard</strong> 提供财务报表的数据订单制分析、以及财务状况支持。我负责将管理层需求进行FineReport报表开发，提供restful接口进行中台整合。技术选型为：FineReport+Springboot+mysql。</p><p>难点：</p><p>第三个项目是广发证券流式日志分析系统<br>流式日志分析系统是ELK大数据可视化分析平台，对各个子系统进行日志数据采集、处理、展示，为内部运维人员提供数据可视化分析。我负责项目招标文件的准备、业务分析、项目调度、业务模块开发等工作。<br>Angluar JS，RESTful Web Services 开发，SQL，PL / SQL 脚本，Elasticsearch， Filebeat，Logstash，Jstorm 脚本，kafka sliptstream elasticsearch&amp;k8s 平台部署，吞吐率性能调优 分布式调度系统 和警报模块的开发和部署。<br>为更好的进行项目管理，业余时间考了pmp。</p><p>难点：</p><p>50 </p><p>后参与杭州弈儒软件技术有限公司十里芳菲西溪湿地度假村项目。负责系列小程序开发工作。</p><p>负责商品管理、房间管理预定、付款和用户管理等的设计开发、以及代码审查和部署。</p><p>难点：</p><p>我对线上问题处理以及性能调优都有自己的理解，对业务的研发设计流程也十分熟悉。如果能有幸加入贵公司一起共事，我想我能第一时间上手并产出结果，以上就是我的自我介绍，谢谢面试官。</p><h1 id="2-java"><a href="#2-java" class="headerlink" title="2,java"></a>2,java</h1><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><a>集合.md</a><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><a>Java基础.md</a><h4 id="java多态及其特性？"><a href="#java多态及其特性？" class="headerlink" title="java多态及其特性？"></a>java多态及其特性？</h4><p><strong>封装</strong>：encapsulation 隐藏信息</p><p><strong>继承</strong>:inheritance 延续+扩展父类信息</p><p><strong>多态</strong>:polymorphism 模糊策略 以不变应万变</p><p>overLoad  overRide</p><h4 id="JAVA-8"><a href="#JAVA-8" class="headerlink" title="JAVA 8"></a>JAVA 8</h4><p>？新特性</p><p>1.hashmap2.JVM,3.streamApi,4.Lambda表达式，Optional等</p><p>流式调用：Java8 Stream 使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合进行链状流式的操作。    </p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。泛型只在编译阶段有效</p><p>泛型类：如：List、Set、Map等集合</p><p>int Integer  Integer 是int包装类，一个是基本类型一个是对象。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>每次线程产生的结果是否有二义性来判断是否是线程安全的。</p><p><strong>如何解决线程安全问题</strong>？<br>（1）使用线程同步机制：通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序缜密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂问题，程序设计和编写难度相对较大。<br>（2）使用ThreadLocal：为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。</p><p>概括起来就是：对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><h4 id="单例，多例和工厂模式"><a href="#单例，多例和工厂模式" class="headerlink" title="单例，多例和工厂模式"></a>单例，多例和工厂模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Car car=<span class="keyword">new</span> Car();   <span class="comment">//实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">()</span></span>&#123;  &#125;   <span class="comment">//构造函数私有</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例模式的getInstance方法==静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> car;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"冒着烟奔跑中car........."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例</strong>：所有请求用同一个对象来处理。通过单例模式，可以保证系统中一个类只有一个实例，getInstance()方法.</p><p>优点：减少新建实例消耗，从而减少JVM了GC回收，性能方面会很有优势。</p><p>缺点：线程不安全，并发可能会出问题。</p><p>spring ioc容器的bean都是默认单例的，那是怎么解决线程安全问题的呢？</p><p>spring单例与线程安全的很多文章中，即有状态bean和无状态bean</p><p><strong>无状态bean</strong>：无状态，就是一次操作，不能保存数据。无状态bean，就是没有实例变量的对象，不能保存数据，是不变类，在线程安全的。<br><strong>有状态bean</strong>：有状态，就是有数据存储功能。有状态bean，就是有实例变量的对象，可以保存数据，是非线程安全的。</p><p><strong>多例</strong>：每个请求用一个新的对象来处理。</p><p><strong>单例如何变多例</strong><br>Scope声明为prototype，即</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure><p><strong>工厂模式：</strong> </p><p>有简单工厂模式、</p><p>抽象工厂模式：产生抽象的工厂</p><p>比如Spring的BeanFactory.通过生成</p><h4 id="？？-arraylist-aragest"><a href="#？？-arraylist-aragest" class="headerlink" title="？？ arraylist  aragest"></a>？？ arraylist  aragest</h4><h4 id="对象的深浅复制"><a href="#对象的深浅复制" class="headerlink" title="对象的深浅复制"></a>对象的深浅复制</h4><p>浅拷贝：浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><ul><li>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</li></ul><p>深拷贝：深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><a>_posts/ JVM.md</a><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程</p><p>平时不怎么使用，也并不主张使用。</p><p>低级接口</p><p>关键字: synchronized<br>Volite  cas线程安全</p><p>高级接口</p><p>框架</p><p>java官方框架</p><p>第三方框架</p><h4 id="线程池优点"><a href="#线程池优点" class="headerlink" title="线程池优点"></a>线程池优点</h4><p>保证线程不溢出，保证系统边界，保证吞吐量</p><p>cpu级 n+1</p><h4 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h4><p>参考： <a href="https://www.cnblogs.com/baizhanshi/p/6419268.html" target="_blank" rel="noopener">https://www.cnblogs.com/baizhanshi/p/6419268.html</a></p><p>线程池的工作机制,Java通过Executors工具类创建出来的线程池有什么区别，为什么这样定义？</p><p>4：线程池有哪些参数，具体含义是什么?<br>4：AQS 重入锁 读写锁 countdownlatch 栅栏（cyclicBarrier） 信号量（semaphore）<br>5：有四个线程A、B、C、D、E，现在需要E线程在ABCD四个线程结束之后再执行</p><p>控制线程顺序执行 我知道的 </p><ol><li>join 让主线程等待子线程运行结束后再继续运行</li><li>利用并发包里的Excutors的newSingleThreadExecutor产生一个单线程的线程池，而这个线程池的底层原理就是一个先进先出（FIFO）的        队列。代码中executor.submit依次添加了123线程，按照FIFO的特性，执行顺序也就是123的执行结果，从而保证了执行顺序。</li><li>使用 CountDownLatch 控制多个线程执行顺序 cutDown()方法和await()方法  参考：<a href="https://www.cnblogs.com/flyme/p/4568063.html" target="_blank" rel="noopener">https://www.cnblogs.com/flyme/p/4568063.html</a></li></ol><p>2.java创建线程是怎么做的？</p><p>5.多线程中线程池的作用？</p><p>6.实现线程池用java那个类来实现？可以创建几种？</p><p>7.线程池的原理？</p><p>8.线程并发的解决方案？redis+Nginx+锁</p><p>9.用过哪些锁？乐观锁，悲观锁，共享锁，自旋锁</p><p>10.这些锁得具体实现？</p><p>40.synchronize是那个层面底层实现的，JVM层面，与reentryLock的区别？</p><p>多线程：</p><p>wait,sleep分别是谁的方法，区别</p><p>sleep是Thread类的方法，wait是Object类的方法。</p><p>countLatch的await方法是否安全，怎么改造</p><p>线程池参数，整个流程描述</p><p>ThreadLocal的使用场景</p><p>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>还有Java的锁，内置锁，显示锁，各种容器</p><p>及锁优化：锁消除，锁粗化，锁偏向，轻量级锁</p><h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3,原理"></a>3,原理</h1><p>CAS</p><p>6.简述一项技术或设计模式的原理 </p><p>背后的底层原理aqs，cas</p><p>ThreadLocal原理，注意事项，参数传递</p><h1 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4,数据库"></a>4,数据库</h1><h4 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h4><p>第一范式（1NF）列的原子性</p><p>第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p>第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>1：索引都有什么类型<br>2：聚集索引和非聚集索引，主键删掉之后还有聚集索引吗？<br>3：建了索引，什么时候会不命中索引<br>4：innodb与myisam存储引擎的区别<br>5：分库分表，主从复制的延迟<br>6：查询优化，</p><p>ACID</p><p>原子性（atomicity，或稱不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）</p><p>redis<br>淘汰机制<br>失效策略<br>持久化rdb、aof<br>pipeline<br>主从、集群</p><p>2.事务,什么是事务,为何用事务 </p><p>保证数据的一致性和完整性</p><p>数据库事物，隔离级别、传播行为，</p><p>1.问下项目应用技术，负责模块，表设计等。</p><p>MySQL</p><p>26.查询优化问题是如何解决的？建索引</p><p>27.读多写少的表应该怎么设计？</p><p>阿里巴巴电话面试二面</p><p>28.有两个整数数组A1，A2，</p><p>设计函数求其两个数组的最大值和第二大的值，说出设计思路？</p><p>29.字符串数组，写函数求字符串最长的公共前缀，例如一是abcdgh，二是abcdhj，那么最长公共前缀是abcd，说出你的设计思路，for循环次数以及意义</p><p>31.表数据大如何诊断查询慢的原因？</p><p>32.索引是什么样的数据结构？Mysql的默认索引形式</p><p>sql优化方式</p><p>sql 三范式</p><p>mysql<br>索引结构 平衡二叉树<br>数据库优化<br>慢sql优化<br>索引（B+树）<br>开启日志导出慢sql<br>分表分库 取模 xy 切割<br>缓存 热数据<br>sql检查 ddl dtl 删除 新建 不能上 去掉</p><p>数据库 隔离级别<br>h2</p><p>数据库：</p><p>最重要的索性及底层实现<br>1）数据库层面上：</p><p>•除了主键索引，唯一索引之外，对于常用的查询字段也要加索引。查询的时候尽量使用主键索引，因为MySQL 的 InnoDB 的主键索引索引的是整行数据，而普通索引索引的是主键，会有回表操作。当然索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，需要酌情考虑。 2、优化查询语句，尽量采用确认性查询语句，减少 or，in，not in，%xxx%语法的使用。</p><p>2）应用层面上：</p><p>•采用缓存机制，将常用的数据进行缓存，增加访问速度；•分库分表，读写分离，将数据分开读写，提升性能</p><p>9、强一致性，弱一致性，最终一致性</p><p>•强一致性：对于更新后的数据，要求后续所有节点的任何操作都要获取最新值的情况；•弱一致性：对于更新后的数据，后续节点的数据操作可以是新值，也可以是旧值，通过一段时间后后续节点对数据的操作都是新值；•最终一致性：是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值。</p><p>10、有一个一百万行的文件，内部是购买的商品ID，如何获取到购买最多的前一百个商品。</p><p>•思路：首先考察的肯定是大数据处理方案，这些数据肯定不能一次性读取到内存，那就需要拆分，将数据分隔处理。假设要分隔为 n 个文件。•分隔：如果 ID 是整型的话，可以直接采用取模（id % n）的方式；如果 ID 是字符串可以先计算 hash 值然后再取模（hash(x) % n）的方式，将相同 ID 的商品分到同一个文件中。•针对每个小文件进行 top100的排序，返回购买最多的100个商品 ID•根据 n 个文件中的100个 ID，在进行一次排序，即可得到需要的数据。</p><p>MySQL事务隔离级别</p><p>事务隔离级别 读未提交（read-uncommitted）不可重复读（read-committed）可重复读（repeatable-read）串行化（serializable）</p><p>索性失效的场景</p><p>最左原则</p><p>查看执行计划</p><p>及carndiation</p><p>然后是锁的类型，行级表级</p><p>悲观乐观锁</p><p>解释数据库事物及特性</p><p>隔离级别</p><p>及实现，redo log .undo log</p><p>bin log主从复制</p><p>mvcc,Next-Key Lock</p><p>分库分表</p><p>MySQL 的事务特性有哪些？</p><p>•首先事务是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行，要么都不执行。事务是一个不可分割的逻辑单元。•A（原子性）事务的各步操作是不可分的，保证一系列的操作要么都完成，要么都不完成；•C（一致性）事务完成，数据必须处于一致的状态；•I（隔离性）对数据进行修改的所有并发事务彼此之间是相互隔离，这表明事务必须是独立的，不应以任何方式依赖或影响其他事务；•D（持久性）表示事务对数据处理结束后，对数据更改必须持久化，不管是事务成功还是回滚。事务日志都能够保持事务的永久性。</p><p>11、如果现在一台生产的数据库挂了怎么处理？</p><p>首先这题没有 get 的面试官想问的点是什么，所以就根据自己项目本身的情况做答了。我们项目生产上的数据库是有主备的，在主数据库挂掉的情况下是会切换到备数据库，先保证业务的稳定性，然后在对崩溃现场进行保留，方便后续分析问题，找到原因。这里面试官追问了一下，我们主备的切换是自动的还是手动的，这个由于是公司运维团队负责的，自己本身不是特别清楚，但是根据对公司运维团队的了解，应该是自动的。所以就这样如实的回答了。</p><p>12、数据库如何实现 rollback 的？</p><p>数据库在写入数据之前是先讲对数据的改动写入 redo log 和 undo log，然后在操作数据，如果成功提交事务就会讲操作写入磁盘；如果失败就会根据redo log 和 undo log 逆向还原到事务操作之前的状态。</p><p>工作这么久你遇到的最难的技术点是什么？</p><p>我这边根据具体的工具经理，回答的是 kafka 的初次使用，因为当时是公司内部第一个引入 kafka，之前没有小组使用过，所以要采很多坑。并且那个时候 kafka 还没有发布1.0版本，官网和网上提供的版本很杂乱不兼容</p><p>8、如果优化数据库的数据查询，另外应用层上还能如何优化？</p><h1 id="5-框架"><a href="#5-框架" class="headerlink" title="5,框架"></a>5,框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>bean的注入过程</p><p>如果要让一个普通类交给Spring容器管理，通常有以下方法：</p><p>1、使用 @Configuration与@Bean 注解</p><p>2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描</p><p>3、使用@Import 方法</p><p>面向切面(AOP),原理是什么 </p><p>spring的IOC、面向切面的原理</p><p>IOC:好莱坞原则，Don’t Call me，I’ll Call you. 控制权由对象翻转成BeanFactory。</p><p>IOC</p><p>AOP：面向</p><p>15.Spring的核心是那两点？分别是怎么做的？</p><p>16.注入类组件的标签？@Autowired，@resource等</p><p>17.那些可以被注入?</p><p>18.注入到Spring容器里，实例化的配置的注解？@Configrution @Bean</p><p>19.Spring有几中配置方式？基于java，基于xml</p><p>20.BeanFactory与Applicationcontext的区别？</p><p>BeanFacotry是spring中比较原始的Factory。如XMLBeanFactory就是一种典型的BeanFactory。原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。ApplicationContext接口,它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能</p><p>21.ApplicationContext有几种实现？</p><p>4种ClassPathXmlApplicationContext:类路径加载</p><p>FileSystemXmlApplicationContext:文件系统路径加载</p><p>AnnotationConfigApplicationContext:用于基于注解的配置</p><p>WebApplicationContext:专门为web应用准备的，从相对于Web根目录的路径中装载配置文件完成初始化。</p><p>@Qualifier的作用?<br>@Qualifier 注释指定注入 Bean 的名称</p><p>23.@requestMapping与@responseBody的替换注解？</p><p>24.传参数的标签， 注解中@RequestParam、@QueryParam、@PathParam和@PathVariable都可以实现</p><p>25.@Autowired与@resource的区别</p><p>spring ioc 、aspect《-cglib（aop）</p><p>SpringBoot 关键词 jpa</p><p>springmvc 单列<br>工厂模式  enum</p><p>spring:</p><p>ioc,aop原理</p><p>ioc初始化流程</p><p>springmvc的流程</p><p>springboot,spring cloud相关组件</p><p>AOP 动态代理<br>JDK代理：基于接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象<br>CGLIB动态代理：如果代理类没有实现 InvocationHandler 接口（或者说是基于父子类的），那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的</p><p>spring提供了5中scope，分别是singleton，prototype，request，session，global session，常用是前两种</p><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><p>mvvc</p><p>SpringMVC</p><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h3><p>服务自发现 Eureka</p><p>负载均衡 Ribbon</p><p>熔断机制 Hystrix</p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/102889333?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_35190492/article/details/102889333?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><p>37.redis的过期时间是如何设置的？为什么这么设计？</p><p>redis使用场景 会话中心 缓存 分布式锁（下单 超卖）并发转队列 消息系统<br>两种模式 本地 了，乐观锁 数据库 cas<br>分几步<br>1量级</p><h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>1.官方</p><p>2.开源</p><p>3.阿里云服务</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>调用链路</p><p>38.dubbo的版本是那个？手动脸红。</p><p>java 区别<br>分布式服务 springboot<br>springcould（7层协议）12factor<br>doubo(5层协议 快) zk ip 端口 服务<br>hessian 序列化 rmi netty canteria<br>eureka zk 服务自发性</p><p>springmvc 单列<br>工厂模式  enum</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven<br>模块化管理<br>nexus</p><p>gitlab<br>gogs git服务</p><p>doker Jenkins<br>travis CI 持续集成</p><p>maven打包怎么跳过测试 </p><p>跳过测试，参数<br>nexus</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>*kafka  kafaka高性能<br>数据可靠性 多个分片<br>ack 01 or<br>吞吐量 15w/s<br>4个节点 3</p><p>ks8</p><p>elk<br>feelbeat<br>elkserch 倒排索引<br>kianan 查询</p><p>4、用过Kafka 的话说下 Kafka优缺点有哪些？</p><p>•Kafka 是一个高吞吐量的消息队列。基本的组件有生产者，消费者，node 节点，生产者负责生产消息，将消息发送到指定的 topic 或者 partition 当中。•每个 partition 可以有多个分区副本，并且存放在不同的 broker 节点上，保证数据的安全。partiton 的底层是根据 segment 段存放的一系列日志文件，文件里面存放的具体的消息内容，每条消息都有一个唯一的 offset 偏移量，并且是按照磁盘顺序存放的。由于磁盘是顺序读写，所以 kafka 可以有很高的吞吐量。磁盘的顺序读写比随机读写的性能高很多。•每个消费者都属于一个消费者组，可以消费指定 topic 下的数据。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Lxc容器</p><p>doker Jenkins 持续集成</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p>小型数据存储中间件，核心是实现paxos算法</p><p>paxos算法，达成共识的选举算法 </p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>SpringBoot Srpingsecurity jpa</p><h2 id="mybitis"><a href="#mybitis" class="headerlink" title="mybitis"></a>mybitis</h2><p>分页查询</p><h1 id="6-Linux"><a href="#6-Linux" class="headerlink" title="6.Linux"></a>6.Linux</h1><p>Linux相关</p><p>33.Linux定时任务如何配置？</p><p><a href="https://www.cnblogs.com/shuaiqing/p/7742382.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuaiqing/p/7742382.html</a></p><p>Linux<br>rz -b<br>scp<br>java - jar<br>tomacat jdk<br>top<br>ps -f<br>nohup 挂起<br>centos</p><p>linux 怎么增量传输 sync java无法增量，前端增量，回滚 </p><h1 id="7-运维"><a href="#7-运维" class="headerlink" title="7.运维"></a>7.运维</h1><p>34.Nginx如何配置负载和代理？</p><p>35.docker命令的差异？拉取镜像，进入容器，docker exec 和Docker attach 区别？</p><p><a href="https://blog.csdn.net/halcyonbaby/article/details/46884605" target="_blank" rel="noopener">https://blog.csdn.net/halcyonbaby/article/details/46884605</a></p><p>shell 脚本</p><p>git  命令组</p><p>Merge、Rebase</p><p>gitlab<br>gogs git服务</p><p>doker Jenkins<br>travis CI 持续集成</p><p>jecker +docker 持续集成</p><p>io阻塞 队列 定长 不定长 回调接口 支付场景<br>查线程挂在哪儿 top -H 查cup最高子进程 gstack 查线程占用 pid号转成16进制的，找到方法名<br>jprofie dump 进程 查看占用量</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>负载均衡</p><p>加权轮询，</p><p>IP哈希</p><p>最少连接数</p><p>一致性哈希</p><p>反向代理 </p><p>nginx 怎么实现粘性会话 ip_hash </p><p>灰度发布</p><p>阿里云 cdn ecs slb rds redis<br>aws</p><h1 id="8-算法"><a href="#8-算法" class="headerlink" title="8.算法"></a>8.算法</h1><p><a href="https://blog.csdn.net/K346K346/article/details/50791102" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/50791102</a></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>常见排序算法分为：</p><p><a href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md</a></p><p>非线性时间比较类排序：</p><p>​    交换类排序(快速排序、冒泡排序)：两两比较，交换不满足顺序要求的偶对，直到全部满足位置。</p><p>​    插入类排序(简单插入排序和希尔排序)：</p><p>​    选择类排序(简单选择排序和堆排序)</p><p>​    归并排序(二路归并排序和多路归并排序)</p><p>线性时间非比较类排序</p><p>​    计数排序、基数排序和桶排序</p><p>冒泡排序：从第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来，找出剩余未排序数中最大数，并冒泡至数列顶端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">                temp = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序</p><h1 id="9-前端"><a href="#9-前端" class="headerlink" title="9.前端"></a>9.前端</h1><p>协议<br>tcp<br>http</p><p>http osi传输模型</p><p>restful</p><p>4.两个项目之间如何通信 10分</p><p>5.在上个问题基础之上问,碰到乱码怎么解决,utf-8和gbk可以直接转换么</p><p>30.前端的es6用过吗？如何写ajax请求</p><p>react</p><p>cors跨域</p><p>vue 怎么进行环境发布<br>webpake</p><p>post， put区别</p><p>PUT可以指定资源路径，POST无法指定资源路径。</p><p>因而，PUT是幂等的操作，即重复操作不会产生变化，10次PUT 的创建请求与1次PUT 的创建请求相同，只会创建一个资源，其实后面9次的请求只是对已创建资源的更新，且更新内容与原内容相同，所以不会产生变化。</p><p>POST 的重复操作截然不同，10次POST请求将会创建10个资源</p><p>web方面：</p><p>servlet是否线程安全，如何改造</p><p>session与cookie的区别，get和post区别，tcp3次握手，文件上传用post还是get</p><p>session的存储</p><p>如何防止表单重复提交</p><p>15、TCP/IP 协议是如何保证数据可靠性的？</p><p>首先 TCP是面向连接的传输协议。主要通过消息确认和重试机制来保证数据传输的可靠性。</p><p>react vue flexible</p><p># </p><h1 id="10-数据结构"><a href="#10-数据结构" class="headerlink" title="10.数据结构"></a>10.数据结构</h1><p>数据结构<br>1：链表，链表倒置、节点交换<br>2：Btree B+tree 红黑树</p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>最后谈谈设计模式，算是一个高频的面试题。</p><p>我们至少要知道以下这些设计模式的功能、代码实现、使用场景问题。</p><p>单例模式、原型模式、工厂模式、观察者模式、策略模式、代理模式等等。</p><h1 id="11-分布式："><a href="#11-分布式：" class="headerlink" title="11,分布式："></a>11,分布式：</h1><p>问了CAP，跟base</p><p>zookeeper满足了CAP的哪些特性，paxos</p><p>缓存穿透怎么解决</p><p>redis的io模型</p><p>如果保证redis高可用</p><p>redis是单线程还是多线程</p><p>Redis 为什么这么高效，使用的场景是什么？</p><p>分布式服务是否了解，zookeeper，dubbo 是否使用过？</p><p>关于 zk 和 dubbo 这块用的不多，zk 主要是在使用 kafka 的时候会用到，但是不涉及原理上面的研究。dubbo 虽然项目中有用过，但是并不是很深入，就没说用过，直接说没用过</p><p>回答了一下我们使用 redis 做缓存和登录 session 存在的场景，以及 redis 是单线程的。</p><p>1、完全基于内存，大多数请求都是内存操作，非常快速； 2、数据结构简单，操作简单； 3、采用单线程，避免了不必要的上下文切换和竞争条件，不存在多进程或者多线程的切换，不用考虑锁带来的性能消耗； 4、使用多路 I/O复用模型，非阻塞 IO</p><p>线上cpu占比过高怎么排查</p><p>一致性hash</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁</p><p>确保分布式锁可用</p><ol><li><strong>互斥性。</strong>在任意时刻，只有一个客户端能持有锁。</li><li><strong>不会发生死锁。</strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li><strong>具有容错性。</strong>只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li><strong>解铃还须系铃人。</strong>加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>设计过什么亮点</p><p>保证幂等 token + redis</p><p>数据库层面 唯一索引</p><p>缓存热数据</p><p>如何避免重复支付</p><p>分布式锁或者本地缓存</p><p>设计模式</p><p>策略模式 aop</p><p>监听者模式</p><p>状态模式</p><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。</p><p>架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。</p><p>性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。</p><p>持续集成 CI</p><p>面经：</p><p>阅文的面试从语言，数据库，网络协议，架构思想访问问</p><p>1、jvm内存结构，堆是由GC负责，谈谈full gc和minor gc的区别（往深处不会。。）</p><p>2、多线程安全策略</p><p>3、hashmap和concurrenthashmap的原理</p><p>4、谈谈cas</p><p>5、sql语句有了解么，规定场景下使用sql查询（好像没有答上）</p><p>6、谈谈acid以及隔离级别</p><p>7、tcp三次握手和四次挥手的区别</p><p>8、给定一个移动端可以点赞，可以查看点赞人数的场景，问怎么实现（当时有点懵逼，短路了，没有思路。。。）</p><p>9、对于上个问题，请求的流转过程，</p><p>10、对于上个问题，假如多个请求同时到达db，怎么减小压力，使用缓存？？？（好像是缓存+分布式锁）</p><p>二面：</p><p>不太像技术面。。。可能一面表现不好</p><p>1、谈谈项目</p><p>2、谈谈与编码的看法不啦不啦。。。。</p><p>hashmap线程安全吗 （不）那怎么改进/有线程安全的hashmap吗 （ConcurrentHashMap）ConcurrentHashMap底层怎么实现的<br>MySQL索引了解吗 几种索引的区别 索引有什么好处（加速查找） 为什么索引效率高（底层用的B+树）B+树的原理说一说<br>Linux 命令了解多少<br>会用git吗<br>堆排序怎么实现的 怎么插入新元素 时间复杂度<br>Tcp三次握手四次挥手 流程</p><p>作者：黄金罗盘_<br>链接：<a href="https://www.nowcoder.com/discuss/118902" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/118902</a><br>来源：牛客网</p><p>一面：<br> 1.问项目，介绍一下，几个人做的，你做的哪部分<br> 2.jvm内存模型<br> 3.几种jvm垃圾回收算法介绍一下，minorGC发生在什么时候<br> 4.复制算法详细介绍一下<br> 5.对象什么时候会进入老年代<br> 6.int和Integer在jvm中怎么存的，两种变量怎么进行比较，Integer i =new Integer(1);Integer j =new Integer(1);i==j成立吗<br> 7.tcp连接三次握手，tcp释放连接四次挥手，讲讲四次挥手的过程，以及为什么连接的时候三次而挥手的时候四次<br> 8.讲讲计算机网络模型<br> 9.http1.0和http1.1主要的区别<br> 10.keep-alive字段的长链接有什么用途<br> 11.熟悉的mysql引擎，哪一个引擎具有行锁<br> 12.写sql语句，一个表有一个字段age，写sql查出age&lt;27，先根据age字段分组，求id最大的那个数据<br> 13.redis项目中怎么用的<br> 14.缓存穿透怎么处理的，你有什么解决方案（我说在项目中商品查询时，先查询redis，没有再查数据库，然后把查询结果存在redis，面试官说如果高并发情况下，多线程同时查一项数据，在线程1查数据库还没返回时，线程2，3等等发现redis缓存没有该数D据，他们也会去查数据库，缓存就失去它的作用，导致缓存穿透，怎么解决）<br> 15.什么叫线程安全，JAVA实现线程安全的方法<br> 16.在并发包中，CAS除了用在原子更新类中，还哪里用到了<br> 17.三个线程执行用时，分别为10秒，9秒，8秒，怎么控制三个线程在10秒完成<br> 18.你熟悉什么设计模式，具体讲讲应用<br>19.过滤器的责任链模式，具体怎么做得<br>20.Linux的创建文件命令，更改文件权限命令，查看进程详细信息命令，具体讲讲chmod命令</p><p> 二面：<br> 1.主要是针对我的两个项目问了不少，你从中学到了什么，你项目的做的亮点，遇到的困难等等<br> 2.项目中数据库用到的最大关联是多少，MySQL中outer join和left join的区别<br> 3.学JAVA开发多久了<br> 4.平时都干啥<br> 5.你对未来的职业规划</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-自我介绍&quot;&gt;&lt;a href=&quot;#1-自我介绍&quot; class=&quot;headerlink&quot; title=&quot;1,自我介绍&quot;&gt;&lt;/a&gt;1,自我介绍&lt;/h1&gt;&lt;p&gt;面试官你好，我叫周芳园，来自深圳，毕业于湖南师范大学树达学院计算机科学与技术专业，2014年毕业，毕业后进入
      
    
    </summary>
    
      <category term="面试" scheme="http://zhoufangy.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>12factor</title>
    <link href="http://zhoufangy.github.io/2020/02/20/12factor/"/>
    <id>http://zhoufangy.github.io/2020/02/20/12factor/</id>
    <published>2020-02-20T00:03:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-一份基准代码，多份部署"><a href="#1-一份基准代码，多份部署" class="headerlink" title="1.一份基准代码，多份部署"></a>1.一份基准代码，多份部署</h5><h5 id="2-显式声明依赖关系"><a href="#2-显式声明依赖关系" class="headerlink" title="2.显式声明依赖关系"></a>2.显式声明依赖关系</h5><h5 id="3-在环境中存储配置"><a href="#3-在环境中存储配置" class="headerlink" title="3.在环境中存储配置"></a>3.在环境中存储配置</h5><h5 id="4-把后端服务当作附加资源"><a href="#4-把后端服务当作附加资源" class="headerlink" title="4.把后端服务当作附加资源"></a>4.把后端服务当作附加资源</h5><h5 id="5-严格分离构建、发布和运行"><a href="#5-严格分离构建、发布和运行" class="headerlink" title="5.严格分离构建、发布和运行"></a>5.严格分离构建、发布和运行</h5><h5 id="6-以一个或多个无状态的进程运行应用"><a href="#6-以一个或多个无状态的进程运行应用" class="headerlink" title="6.以一个或多个无状态的进程运行应用"></a>6.以一个或多个无状态的进程运行应用</h5><h5 id="7-通过端口绑定提供服务"><a href="#7-通过端口绑定提供服务" class="headerlink" title="7.通过端口绑定提供服务"></a>7.通过端口绑定提供服务</h5><h5 id="8-通过进程模型进行扩展"><a href="#8-通过进程模型进行扩展" class="headerlink" title="8.通过进程模型进行扩展"></a>8.通过进程模型进行扩展</h5><h5 id="9-快速启动和优雅终止可最大化健壮性"><a href="#9-快速启动和优雅终止可最大化健壮性" class="headerlink" title="9.快速启动和优雅终止可最大化健壮性"></a>9.快速启动和优雅终止可最大化健壮性</h5><h5 id="10-开发环境与线上环境等价"><a href="#10-开发环境与线上环境等价" class="headerlink" title="10.开发环境与线上环境等价"></a>10.开发环境与线上环境等价</h5><h5 id="11-把日志当作事件流"><a href="#11-把日志当作事件流" class="headerlink" title="11.把日志当作事件流"></a>11.把日志当作事件流</h5><h5 id="12-后台管理任务当作一次性进程运行"><a href="#12-后台管理任务当作一次性进程运行" class="headerlink" title="12.后台管理任务当作一次性进程运行"></a>12.后台管理任务当作一次性进程运行</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-一份基准代码，多份部署&quot;&gt;&lt;a href=&quot;#1-一份基准代码，多份部署&quot; class=&quot;headerlink&quot; title=&quot;1.一份基准代码，多份部署&quot;&gt;&lt;/a&gt;1.一份基准代码，多份部署&lt;/h5&gt;&lt;h5 id=&quot;2-显式声明依赖关系&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="概念" scheme="http://zhoufangy.github.io/categories/%E6%A6%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Travis CI 自动部署Hexo博客至Github</title>
    <link href="http://zhoufangy.github.io/2020/02/15/Travis-CI-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo%E8%87%B3Github/"/>
    <id>http://zhoufangy.github.io/2020/02/15/Travis-CI-自动部署Hexo至Github/</id>
    <published>2020-02-15T18:51:07.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Github配置"><a href="#1-Github配置" class="headerlink" title="1.Github配置"></a>1.Github配置</h5><p>Github创建项目xxx.github.io,master为静态页面展示项目，code为hexo代码。</p><h5 id="2-Travis-CI配置"><a href="#2-Travis-CI配置" class="headerlink" title="2.Travis CI配置"></a>2.Travis CI配置</h5><p> 用 Github 账号注册并登录 Travis CI，配置好 Travis CI 在 Github 的权限和 Token。</p><h5 id="3-在code分支下新建配置文件-travis-yml"><a href="#3-在code分支下新建配置文件-travis-yml" class="headerlink" title="3.在code分支下新建配置文件 .travis.yml"></a>3.在code分支下新建配置文件 .travis.yml</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo: <span class="literal">false</span></span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 </span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - code <span class="comment"># 当hexo分支有新的commit时执行 </span></span><br><span class="line">script:</span><br><span class="line">  - hexo generate </span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">local</span>-dir: public</span><br><span class="line">  target-branch: master <span class="comment"># 注意这里是部署到master, 默认是到gh-pages</span></span><br><span class="line">  github-token: <span class="variable">$GH_TOKEN</span></span><br><span class="line">  keep-history: <span class="literal">true</span></span><br><span class="line">  on:</span><br><span class="line">    branch: code <span class="comment"># 博客的源码分支</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h5 id="4-推送代码至code分支，完成部署"><a href="#4-推送代码至code分支，完成部署" class="headerlink" title="4.推送代码至code分支，完成部署"></a>4.推送代码至code分支，完成部署</h5><h5 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h5><p><a href="https://blog.csdn.net/badcow/article/details/102503102" target="_blank" rel="noopener">https://blog.csdn.net/badcow/article/details/102503102</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-Github配置&quot;&gt;&lt;a href=&quot;#1-Github配置&quot; class=&quot;headerlink&quot; title=&quot;1.Github配置&quot;&gt;&lt;/a&gt;1.Github配置&lt;/h5&gt;&lt;p&gt;Github创建项目xxx.github.io,master为静态页面展示项
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Travis CI 自动部署Hexo博客至Github</title>
    <link href="http://zhoufangy.github.io/2020/02/15/Spring/"/>
    <id>http://zhoufangy.github.io/2020/02/15/Spring/</id>
    <published>2020-02-15T18:51:07.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-Github配置"><a href="#1-Github配置" class="headerlink" title="1.Github配置"></a>1.Github配置</h5><p>Github创建项目xxx.github.io,master为静态页面展示项目，code为hexo代码。</p><h5 id="2-Travis-CI配置"><a href="#2-Travis-CI配置" class="headerlink" title="2.Travis CI配置"></a>2.Travis CI配置</h5><p> 用 Github 账号注册并登录 Travis CI，配置好 Travis CI 在 Github 的权限和 Token。</p><h5 id="3-在code分支下新建配置文件-travis-yml"><a href="#3-在code分支下新建配置文件-travis-yml" class="headerlink" title="3.在code分支下新建配置文件 .travis.yml"></a>3.在code分支下新建配置文件 .travis.yml</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo: <span class="literal">false</span></span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 </span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">    only:</span><br><span class="line">    - code <span class="comment"># 当hexo分支有新的commit时执行 </span></span><br><span class="line">script:</span><br><span class="line">  - hexo generate </span><br><span class="line">deploy:</span><br><span class="line">    provider: pages</span><br><span class="line">    skip-cleanup: <span class="literal">true</span></span><br><span class="line">    <span class="built_in">local</span>-dir: public</span><br><span class="line">    target-branch: master <span class="comment"># 注意这里是部署到master, 默认是到gh-pages</span></span><br><span class="line">    github-token: <span class="variable">$GH_TOKEN</span></span><br><span class="line">    keep-history: <span class="literal">true</span></span><br><span class="line">    on:</span><br><span class="line">    branch: code <span class="comment"># 博客的源码分支</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-推送代码至code分支，完成部署"><a href="#4-推送代码至code分支，完成部署" class="headerlink" title="4.推送代码至code分支，完成部署"></a>4.推送代码至code分支，完成部署</h5><h5 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h5><p><a href="https://blog.csdn.net/badcow/article/details/102503102" target="_blank" rel="noopener">https://blog.csdn.net/badcow/article/details/102503102</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-Github配置&quot;&gt;&lt;a href=&quot;#1-Github配置&quot; class=&quot;headerlink&quot; title=&quot;1.Github配置&quot;&gt;&lt;/a&gt;1.Github配置&lt;/h5&gt;&lt;p&gt;Github创建项目xxx.github.io,master为静态页面展示项
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo迁移报错目录丢失Cannot GET /</title>
    <link href="http://zhoufangy.github.io/2020/02/15/Hexo%E8%BF%81%E7%A7%BB%E6%8A%A5%E9%94%99%E7%9B%AE%E5%BD%95%E4%B8%A2%E5%A4%B1Cannot-GET/"/>
    <id>http://zhoufangy.github.io/2020/02/15/Hexo迁移报错目录丢失Cannot-GET/</id>
    <published>2020-02-15T11:56:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>迁移Hexo后部署主页丢失，访问目录报Cannot GET /。index页面可单独访问</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>检查缺失组建<br>npm audit fix<br>更新<br>npm install</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;迁移Hexo后部署主页丢失，访问目录报Cannot GET /。index页面可单独访问&lt;/p&gt;
&lt;h4 id=&quot;解决办法&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Hexo" scheme="http://zhoufangy.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://zhoufangy.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>更新Xcode后Git报错</title>
    <link href="http://zhoufangy.github.io/2020/02/15/%E6%9B%B4%E6%96%B0Xcode%E5%90%8EGit%E6%8A%A5%E9%94%99/"/>
    <id>http://zhoufangy.github.io/2020/02/15/更新Xcode后Git报错/</id>
    <published>2020-02-15T10:56:00.000Z</published>
    <updated>2020-03-25T18:42:39.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Accept Xcode/iOS license to Run Git</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>终端输入sudo xcodebuild -license<br>输入密码后同意条款,用空格键跳到最后</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">By typing <span class="string">'agree'</span> you are agreeing to the terms of the software license agreements. Type <span class="string">'print'</span> to <span class="built_in">print</span> them or anything <span class="keyword">else</span> to cancel, [agree, <span class="built_in">print</span>, cancel] agree</span><br><span class="line"></span><br><span class="line">You can view the license agreements <span class="keyword">in</span> Xcode<span class="string">'s About Box, or at /Applications/Xcode.app/Contents/Resources/English.lproj/License.rtf</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;Accept Xcode/iOS license to Run Git&lt;/p&gt;
&lt;h4 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; 
      
    
    </summary>
    
      <category term="Git" scheme="http://zhoufangy.github.io/categories/Git/"/>
    
    
      <category term="Git 报错" scheme="http://zhoufangy.github.io/tags/Git-%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
</feed>
